Processing grammar.
$accept(0)
$end(1)
error(2)
compilationUnit(3)
packageDeclaration(4)
EOF(5)
importDeclarations(6)
typeDeclarations(7)
SEMI(8)
annotationl(9)
PACKAGE(10)
qualifiedName(11)
importDeclaration(12)
IMPORT(13)
STATIC(14)
DOT(15)
MUL(16)
typeDeclarationWithPrefixes(17)
modifierL(18)
typeDeclaration(19)
classDeclaration(20)
interfaceDeclaration(21)
enumDeclaration(22)
annotationTypeDeclaration(23)
CLASS(24)
Identifier(25)
classInheritance(26)
interfaceImplentation(27)
classBody(28)
typeParameters(29)
EXTENDS(30)
type(31)
IMPLEMENTS(32)
typeList(33)
TEMPLATE(34)
ENUM(35)
enumBody(36)
LBRACE(37)
RBRACE(38)
enumBodyDeclaration(39)
enumConstants(40)
COMMA(41)
classBodyDeclarationl(42)
enumOptionalConstantDeclaration(43)
enumOptionalClassBody(44)
annotations(45)
enumConstantArguments(46)
enumConstantClassBody(47)
enumConstant(48)
arguments(49)
INTERFACE(50)
optionalTypeParameters(51)
interfaceBody(52)
classBodyDeclarations(53)
classBodyDeclaration(54)
classStaticBlock(55)
block(56)
interfaceBodyDeclarationl(57)
interfaceBodyDeclarations(58)
interfaceBodyDeclaration(59)
classMemberDeclaration(60)
staticBlock(61)
modifier(62)
FINAL(63)
ABSTRACT(64)
STRICTFP(65)
TRANSIENT(66)
VOLATILE(67)
PUBLIC(68)
PRIVATE(69)
PROTECTED(70)
NATIVE(71)
SYNCHRONIZED(72)
modifiers(73)
VOID(74)
formalParameters(75)
arrayDimensionBracks(76)
throwsList(77)
variableDeclarators(78)
THROWS(79)
qualifiedNameList(80)
interfaceMemberDeclaration(81)
constDelarators(82)
constDeclaration(83)
constantDeclarator(84)
ASSIGN(85)
variableInitializer(86)
arrayDimensionBrackl(87)
variableDeclarator(88)
variableDeclaratorId(89)
arrayInitializer(90)
expression(91)
variableInitializerL(92)
enumConstantName(93)
primitiveType(94)
arrayDimensionBrack(95)
LBRACK(96)
RBRACK(97)
classOrInterfaceType(98)
BOOLEAN(99)
CHAR(100)
BYTE(101)
SHORT(102)
INT(103)
LONG(104)
FLOAT(105)
DOUBLE(106)
typeArguments(107)
LT(108)
typeArgumentList(109)
GT(110)
typeArgument(111)
QUESTION(112)
SUPER(113)
typeArgument_(114)
LPAREN(115)
RPAREN(116)
formalParameterList(117)
usualParameterList(118)
lastFormalParameter(119)
usualParameter(120)
variableModifiers(121)
variableModifierL(122)
variableModifier(123)
ELLIPSIS(124)
methodBody(125)
constructorBody(126)
literal(127)
IntegerLiteral(128)
FloatingPointLiteral(129)
CharacterLiteral(130)
StringLiteral(131)
BooleanLiteral(132)
NullLiteral(133)
annotation(134)
AT(135)
elementValueList(136)
elementValuePairs(137)
annotationOptValues(138)
annotationElement(139)
elementValue(140)
annotationName(141)
elementValuePair(142)
elementValueArrayInitializer(143)
elementValueListOpt(144)
annotationTypeBody(145)
annotationTypeElementDeclarations(146)
annotationTypeElementDeclaration(147)
annotationTypeElementRest(148)
annotationConstantRest(149)
annotationMethodRest(150)
semiOpt(151)
defaultValue(152)
defaultValueOpt(153)
DEFAULT(154)
blockStatementList(155)
blockStatements(156)
blockStatement(157)
statement(158)
localVariableDeclarationStatement(159)
localVariableDeclaration(160)
assertExpression(161)
COLON(162)
optionalElseStatement(163)
ELSE(164)
ASSERT(165)
IF(166)
FOR(167)
forControl(168)
WHILE(169)
DO(170)
TRY(171)
catchFinallyOrOnlyFinally(172)
resourceSpecification(173)
catchClauses(174)
optionalFinallyBlock(175)
SWITCH(176)
switchBlockStatementGroups(177)
emptySwitchLabels(178)
RETURN(179)
THROW(180)
BREAK(181)
optionalIdentifier(182)
CONTINUE(183)
variableDeclaratorsWithPrefixes(184)
simpleExpressionStatement(185)
finallyBlock(186)
catchClause(187)
CATCH(188)
catchType(189)
BITOR(190)
FINALLY(191)
resources(192)
resource(193)
switchBlockStatementGroupL(194)
switchBlockStatementGroup(195)
switchLabelL(196)
switchLabel(197)
CASE(198)
enhancedForControl(199)
forInit(200)
optionalExpression(201)
optionalForUpdate(202)
optionalForInit(203)
forUpdate(204)
expressionList(205)
parExpression(206)
optionalExpressionList(207)
statementExpression(208)
constantExpression(209)
optionalNonWildcardTypeArguments(210)
nonWildcardTypeArguments(211)
incrementOrDecrement(212)
INC(213)
DEC(214)
plusMinusIncOrDec(215)
ADD(216)
SUB(217)
prefixTildeOrBang(218)
TILDE(219)
BANG(220)
mulDivOrMod(221)
DIV(222)
MOD(223)
addOrSub(224)
bitShiftOperator(225)
lE_GE_LT_GT(226)
LE(227)
GE(228)
equals_NotEqual(229)
EQUAL(230)
NOTEQUAL(231)
assignmentToken(232)
ADD_ASSIGN(233)
SUB_ASSIGN(234)
MUL_ASSIGN(235)
DIV_ASSIGN(236)
AND_ASSIGN(237)
OR_ASSIGN(238)
XOR_ASSIGN(239)
RSHIFT_ASSIGN(240)
URSHIFT_ASSIGN(241)
LSHIFT_ASSIGN(242)
MOD_ASSIGN(243)
newCreator(244)
NEW(245)
creator(246)
THIS(247)
innerCreator(248)
explicitGenericInvocation(249)
LSHIFT(250)
INSTANCEOF(251)
BITAND(252)
CARET(253)
AND(254)
OR(255)
explicitGenericInvocationSuffixOrThisArgs(256)
explicitGenericInvocationSuffix(257)
createdName(258)
classCreatorRest(259)
arrayOrClassCreator(260)
arrayCreatorRest(261)
optionalTypeArgumentsOrDiamonds(262)
typeArgumentsOrDiamondList(263)
typeArgumentsOrDiamond(264)
optionalNonWildcardTypeArgumentsOrDiamond(265)
nonWildcardTypeArgumentsOrDiamond(266)
bracketedExpressions(267)
optionalClassBody(268)
superSuffix(269)
optionalArguments(270)
optionalCOMMA(271)

Item sets
------

item set 0 
$accept -> .compilationUnit $end #lookaheads= $end
compilationUnit -> .packageDeclaration EOF
compilationUnit -> .packageDeclaration importDeclarations EOF
compilationUnit -> .packageDeclaration importDeclarations typeDeclarations EOF
compilationUnit -> .packageDeclaration typeDeclarations EOF
compilationUnit -> .importDeclarations typeDeclarations EOF
compilationUnit -> .typeDeclarations EOF
compilationUnit -> .SEMI
packageDeclaration -> .annotationl packageDeclaration
packageDeclaration -> .packageDeclaration
packageDeclaration -> .PACKAGE qualifiedName SEMI
importDeclarations -> .importDeclaration
importDeclarations -> .importDeclarations importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
annotationl -> .annotation
annotationl -> .annotationl annotation
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"compilationUnit":1,"packageDeclaration":2,"importDeclarations":3,"typeDeclarations":4,"SEMI":5,"annotationl":6,"PACKAGE":7,"importDeclaration":8,"typeDeclarationWithPrefixes":9,"annotation":10,"IMPORT":11,"modifierL":12,"typeDeclaration":13,"AT":14,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 1 
$accept -> compilationUnit .$end #lookaheads= $end 
transitions ->  {}

item set 2 
compilationUnit -> packageDeclaration .EOF
compilationUnit -> packageDeclaration .importDeclarations EOF
compilationUnit -> packageDeclaration .importDeclarations typeDeclarations EOF
compilationUnit -> packageDeclaration .typeDeclarations EOF
packageDeclaration -> packageDeclaration .
importDeclarations -> .importDeclaration
importDeclarations -> .importDeclarations importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"EOF":34,"importDeclarations":35,"typeDeclarations":36,"importDeclaration":8,"typeDeclarationWithPrefixes":9,"IMPORT":11,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 3 
compilationUnit -> importDeclarations .typeDeclarations EOF
importDeclarations -> importDeclarations .importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"typeDeclarations":39,"importDeclaration":40,"typeDeclarationWithPrefixes":9,"IMPORT":11,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 4 
compilationUnit -> typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"EOF":41,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 5 
compilationUnit -> SEMI .
typeDeclaration -> SEMI . 
transitions ->  {}

item set 6 
packageDeclaration -> annotationl .packageDeclaration
annotationl -> annotationl .annotation
typeDeclarationWithPrefixes -> annotationl .modifierL typeDeclaration
typeDeclarationWithPrefixes -> annotationl .typeDeclaration
packageDeclaration -> .annotationl packageDeclaration
packageDeclaration -> .packageDeclaration
packageDeclaration -> .PACKAGE qualifiedName SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotationl -> .annotation
annotationl -> .annotationl annotation
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"packageDeclaration":43,"annotation":44,"modifierL":45,"typeDeclaration":46,"annotationl":47,"PACKAGE":7,"AT":14,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 7 
packageDeclaration -> PACKAGE .qualifiedName SEMI
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":48,"Identifier":49}

item set 8 
importDeclarations -> importDeclaration . 
transitions ->  {}

item set 9 
typeDeclarations -> typeDeclarationWithPrefixes . 
transitions ->  {}

item set 10 
annotationl -> annotation . 
transitions ->  {}

item set 11 
importDeclaration -> IMPORT .STATIC qualifiedName DOT MUL SEMI
importDeclaration -> IMPORT .STATIC qualifiedName SEMI
importDeclaration -> IMPORT .qualifiedName DOT MUL SEMI
importDeclaration -> IMPORT .qualifiedName SEMI
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"STATIC":50,"qualifiedName":51,"Identifier":49}

item set 12 
typeDeclarationWithPrefixes -> modifierL .annotationl typeDeclaration
typeDeclarationWithPrefixes -> modifierL .typeDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"annotationl":52,"typeDeclaration":53,"modifier":54,"annotation":10,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 13 
typeDeclarationWithPrefixes -> typeDeclaration . 
transitions ->  {}

item set 14 
annotation -> AT .qualifiedName
annotation -> AT .qualifiedName LPAREN elementValueList RPAREN
annotation -> AT .qualifiedName LPAREN elementValuePairs RPAREN
annotationTypeDeclaration -> AT .INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> AT .INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":55,"INTERFACE":56,"Identifier":49}

item set 15 
modifierL -> modifier . 
transitions ->  {}

item set 16 
typeDeclaration -> classDeclaration . 
transitions ->  {}

item set 17 
typeDeclaration -> interfaceDeclaration . 
transitions ->  {}

item set 18 
typeDeclaration -> enumDeclaration . 
transitions ->  {}

item set 19 
typeDeclaration -> annotationTypeDeclaration . 
transitions ->  {}

item set 20 
modifier -> STATIC . 
transitions ->  {}

item set 21 
modifier -> FINAL . 
transitions ->  {}

item set 22 
modifier -> ABSTRACT . 
transitions ->  {}

item set 23 
modifier -> STRICTFP . 
transitions ->  {}

item set 24 
modifier -> TRANSIENT . 
transitions ->  {}

item set 25 
modifier -> VOLATILE . 
transitions ->  {}

item set 26 
modifier -> PUBLIC . 
transitions ->  {}

item set 27 
modifier -> PRIVATE . 
transitions ->  {}

item set 28 
modifier -> PROTECTED . 
transitions ->  {}

item set 29 
modifier -> NATIVE . 
transitions ->  {}

item set 30 
modifier -> SYNCHRONIZED . 
transitions ->  {}

item set 31 
classDeclaration -> CLASS .Identifier classInheritance interfaceImplentation classBody
classDeclaration -> CLASS .Identifier typeParameters classInheritance interfaceImplentation classBody 
transitions ->  {"Identifier":57}

item set 32 
interfaceDeclaration -> INTERFACE .Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> INTERFACE .Identifier optionalTypeParameters EXTENDS typeList interfaceBody 
transitions ->  {"Identifier":58}

item set 33 
enumDeclaration -> ENUM .Identifier interfaceImplentation enumBody 
transitions ->  {"Identifier":59}

item set 34 
compilationUnit -> packageDeclaration EOF . 
transitions ->  {}

item set 35 
compilationUnit -> packageDeclaration importDeclarations .EOF
compilationUnit -> packageDeclaration importDeclarations .typeDeclarations EOF
importDeclarations -> importDeclarations .importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"EOF":60,"typeDeclarations":61,"importDeclaration":40,"typeDeclarationWithPrefixes":9,"IMPORT":11,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 36 
compilationUnit -> packageDeclaration typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"EOF":62,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 37 
typeDeclarationWithPrefixes -> annotationl .modifierL typeDeclaration
typeDeclarationWithPrefixes -> annotationl .typeDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"modifierL":45,"typeDeclaration":46,"annotation":63,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 38 
typeDeclaration -> SEMI . 
transitions ->  {}

item set 39 
compilationUnit -> importDeclarations typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"EOF":64,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 40 
importDeclarations -> importDeclarations importDeclaration . 
transitions ->  {}

item set 41 
compilationUnit -> typeDeclarations EOF . 
transitions ->  {}

item set 42 
typeDeclarations -> typeDeclarations typeDeclarationWithPrefixes . 
transitions ->  {}

item set 43 
packageDeclaration -> annotationl packageDeclaration .
packageDeclaration -> packageDeclaration . 
transitions ->  {}

item set 44 
annotationl -> annotationl annotation .
annotationl -> annotation . 
transitions ->  {}

item set 45 
typeDeclarationWithPrefixes -> annotationl modifierL .typeDeclaration
modifierL -> modifierL .modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"typeDeclaration":65,"modifier":54,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66}

item set 46 
typeDeclarationWithPrefixes -> annotationl typeDeclaration . 
transitions ->  {}

item set 47 
packageDeclaration -> annotationl .packageDeclaration
annotationl -> annotationl .annotation
packageDeclaration -> .annotationl packageDeclaration
packageDeclaration -> .packageDeclaration
packageDeclaration -> .PACKAGE qualifiedName SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
annotationl -> .annotation
annotationl -> .annotationl annotation 
transitions ->  {"packageDeclaration":43,"annotation":44,"annotationl":47,"PACKAGE":7,"AT":67}

item set 48 
packageDeclaration -> PACKAGE qualifiedName .SEMI
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"SEMI":68,"DOT":69}

item set 49 
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeParameters":70,"TEMPLATE":71}

item set 50 
importDeclaration -> IMPORT STATIC .qualifiedName DOT MUL SEMI
importDeclaration -> IMPORT STATIC .qualifiedName SEMI
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":72,"Identifier":49}

item set 51 
importDeclaration -> IMPORT qualifiedName .DOT MUL SEMI
importDeclaration -> IMPORT qualifiedName .SEMI
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":73,"SEMI":74}

item set 52 
typeDeclarationWithPrefixes -> modifierL annotationl .typeDeclaration
annotationl -> annotationl .annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"typeDeclaration":75,"annotation":63,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 53 
typeDeclarationWithPrefixes -> modifierL typeDeclaration . 
transitions ->  {}

item set 54 
modifierL -> modifierL modifier . 
transitions ->  {}

item set 55 
annotation -> AT qualifiedName .
annotation -> AT qualifiedName .LPAREN elementValueList RPAREN
annotation -> AT qualifiedName .LPAREN elementValuePairs RPAREN
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"LPAREN":76,"DOT":69}

item set 56 
annotationTypeDeclaration -> AT INTERFACE .Identifier annotationTypeBody
annotationTypeDeclaration -> AT INTERFACE .Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"Identifier":77}

item set 57 
classDeclaration -> CLASS Identifier .classInheritance interfaceImplentation classBody
classDeclaration -> CLASS Identifier .typeParameters classInheritance interfaceImplentation classBody
classInheritance -> .
classInheritance -> .EXTENDS type
typeParameters -> .TEMPLATE 
transitions ->  {"classInheritance":78,"typeParameters":79,"EXTENDS":80,"TEMPLATE":71}

item set 58 
interfaceDeclaration -> INTERFACE Identifier .optionalTypeParameters interfaceBody
interfaceDeclaration -> INTERFACE Identifier .optionalTypeParameters EXTENDS typeList interfaceBody
optionalTypeParameters -> .
optionalTypeParameters -> .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"optionalTypeParameters":81,"typeParameters":82,"TEMPLATE":71}

item set 59 
enumDeclaration -> ENUM Identifier .interfaceImplentation enumBody
interfaceImplentation -> .
interfaceImplentation -> .IMPLEMENTS typeList 
transitions ->  {"interfaceImplentation":83,"IMPLEMENTS":84}

item set 60 
compilationUnit -> packageDeclaration importDeclarations EOF . 
transitions ->  {}

item set 61 
compilationUnit -> packageDeclaration importDeclarations typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"EOF":85,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 62 
compilationUnit -> packageDeclaration typeDeclarations EOF . 
transitions ->  {}

item set 63 
annotationl -> annotationl annotation . 
transitions ->  {}

item set 64 
compilationUnit -> importDeclarations typeDeclarations EOF . 
transitions ->  {}

item set 65 
typeDeclarationWithPrefixes -> annotationl modifierL typeDeclaration . 
transitions ->  {}

item set 66 
annotationTypeDeclaration -> AT .INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> AT .INTERFACE Identifier EXTENDS typeList annotationTypeBody 
transitions ->  {"INTERFACE":56}

item set 67 
annotation -> AT .qualifiedName
annotation -> AT .qualifiedName LPAREN elementValueList RPAREN
annotation -> AT .qualifiedName LPAREN elementValuePairs RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":55,"Identifier":49}

item set 68 
packageDeclaration -> PACKAGE qualifiedName SEMI . 
transitions ->  {}

item set 69 
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters 
transitions ->  {"Identifier":86}

item set 70 
qualifiedName -> Identifier typeParameters . 
transitions ->  {}

item set 71 
typeParameters -> TEMPLATE . 
transitions ->  {}

item set 72 
importDeclaration -> IMPORT STATIC qualifiedName .DOT MUL SEMI
importDeclaration -> IMPORT STATIC qualifiedName .SEMI
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":87,"SEMI":88}

item set 73 
importDeclaration -> IMPORT qualifiedName DOT .MUL SEMI
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters 
transitions ->  {"MUL":89,"Identifier":86}

item set 74 
importDeclaration -> IMPORT qualifiedName SEMI . 
transitions ->  {}

item set 75 
typeDeclarationWithPrefixes -> modifierL annotationl typeDeclaration . 
transitions ->  {}

item set 76 
annotation -> AT qualifiedName LPAREN .elementValueList RPAREN
annotation -> AT qualifiedName LPAREN .elementValuePairs RPAREN
elementValueList -> .elementValue
elementValueList -> .elementValueList COMMA elementValue
elementValuePairs -> .elementValuePair
elementValuePairs -> .elementValuePairs COMMA elementValuePair
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
elementValuePair -> .Identifier ASSIGN elementValue
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValueList":90,"elementValuePairs":91,"elementValue":92,"elementValuePair":93,"expression":94,"annotations":95,"LBRACE":96,"Identifier":97,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 77 
annotationTypeDeclaration -> AT INTERFACE Identifier .annotationTypeBody
annotationTypeDeclaration -> AT INTERFACE Identifier .EXTENDS typeList annotationTypeBody
annotationTypeBody -> .LBRACE RBRACE
annotationTypeBody -> .LBRACE annotationTypeElementDeclarations RBRACE 
transitions ->  {"annotationTypeBody":132,"EXTENDS":133,"LBRACE":134}

item set 78 
classDeclaration -> CLASS Identifier classInheritance .interfaceImplentation classBody
interfaceImplentation -> .
interfaceImplentation -> .IMPLEMENTS typeList 
transitions ->  {"interfaceImplentation":135,"IMPLEMENTS":84}

item set 79 
classDeclaration -> CLASS Identifier typeParameters .classInheritance interfaceImplentation classBody
classInheritance -> .
classInheritance -> .EXTENDS type 
transitions ->  {"classInheritance":136,"EXTENDS":80}

item set 80 
classInheritance -> EXTENDS .type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":137,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 81 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters .interfaceBody
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters .EXTENDS typeList interfaceBody
interfaceBody -> .LBRACE RBRACE
interfaceBody -> .LBRACE interfaceBodyDeclarationl RBRACE 
transitions ->  {"interfaceBody":140,"EXTENDS":141,"LBRACE":142}

item set 82 
optionalTypeParameters -> typeParameters . 
transitions ->  {}

item set 83 
enumDeclaration -> ENUM Identifier interfaceImplentation .enumBody
enumBody -> .LBRACE RBRACE
enumBody -> .LBRACE enumBodyDeclaration RBRACE 
transitions ->  {"enumBody":143,"LBRACE":144}

item set 84 
interfaceImplentation -> IMPLEMENTS .typeList
typeList -> .type
typeList -> .typeList COMMA type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeList":145,"type":146,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 85 
compilationUnit -> packageDeclaration importDeclarations typeDeclarations EOF . 
transitions ->  {}

item set 86 
qualifiedName -> qualifiedName DOT Identifier .
qualifiedName -> qualifiedName DOT Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeParameters":147,"TEMPLATE":71}

item set 87 
importDeclaration -> IMPORT STATIC qualifiedName DOT .MUL SEMI
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters 
transitions ->  {"MUL":148,"Identifier":86}

item set 88 
importDeclaration -> IMPORT STATIC qualifiedName SEMI . 
transitions ->  {}

item set 89 
importDeclaration -> IMPORT qualifiedName DOT MUL .SEMI 
transitions ->  {"SEMI":149}

item set 90 
annotation -> AT qualifiedName LPAREN elementValueList .RPAREN
elementValueList -> elementValueList .COMMA elementValue 
transitions ->  {"RPAREN":150,"COMMA":151}

item set 91 
annotation -> AT qualifiedName LPAREN elementValuePairs .RPAREN
elementValuePairs -> elementValuePairs .COMMA elementValuePair 
transitions ->  {"RPAREN":152,"COMMA":153}

item set 92 
elementValueList -> elementValue . 
transitions ->  {}

item set 93 
elementValuePairs -> elementValuePair . 
transitions ->  {}

item set 94 
elementValue -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 95 
elementValue -> annotations . 
transitions ->  {}

item set 96 
elementValue -> LBRACE .RBRACE
elementValue -> LBRACE .elementValueList RBRACE
elementValueList -> .elementValue
elementValueList -> .elementValueList COMMA elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"RBRACE":197,"elementValueList":198,"elementValue":92,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 97 
elementValuePair -> Identifier .ASSIGN elementValue
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"ASSIGN":199,"typeParameters":70,"TEMPLATE":71}

item set 98 
expression -> parExpression .
expression -> parExpression .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":200,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 99 
expression -> qualifiedName .
expression -> qualifiedName .DOT CLASS
expression -> qualifiedName .DOT SUPER
expression -> qualifiedName .DOT SUPER DOT expression
expression -> qualifiedName .DOT newCreator
expression -> qualifiedName .arrayDimensionBrackl DOT CLASS
expression -> qualifiedName .DOT THIS
expression -> qualifiedName .DOT explicitGenericInvocation
expression -> qualifiedName .LBRACK expression RBRACK
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":201,"arrayDimensionBrackl":202,"LBRACK":203,"arrayDimensionBrack":204}

item set 100 
expression -> primitiveType .DOT CLASS
expression -> primitiveType .arrayDimensionBrackl DOT CLASS
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":205,"arrayDimensionBrackl":206,"arrayDimensionBrack":204,"LBRACK":207}

item set 101 
expression -> newCreator . 
transitions ->  {}

item set 102 
expression -> plusMinusIncOrDec .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":208,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 103 
expression -> prefixTildeOrBang .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":209,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 104 
expression -> THIS . 
transitions ->  {}

item set 105 
expression -> SUPER . 
transitions ->  {}

item set 106 
expression -> IntegerLiteral . 
transitions ->  {}

item set 107 
expression -> FloatingPointLiteral . 
transitions ->  {}

item set 108 
expression -> CharacterLiteral . 
transitions ->  {}

item set 109 
expression -> StringLiteral . 
transitions ->  {}

item set 110 
expression -> BooleanLiteral . 
transitions ->  {}

item set 111 
expression -> NullLiteral . 
transitions ->  {}

item set 112 
expression -> VOID .DOT CLASS 
transitions ->  {"DOT":210}

item set 113 
expression -> nonWildcardTypeArguments .explicitGenericInvocationSuffixOrThisArgs
explicitGenericInvocationSuffixOrThisArgs -> .explicitGenericInvocationSuffix
explicitGenericInvocationSuffixOrThisArgs -> .THIS arguments
explicitGenericInvocationSuffix -> .SUPER superSuffix
explicitGenericInvocationSuffix -> .Identifier arguments 
transitions ->  {"explicitGenericInvocationSuffixOrThisArgs":211,"explicitGenericInvocationSuffix":212,"THIS":213,"SUPER":214,"Identifier":215}

item set 114 
annotations -> annotationl .
annotationl -> annotationl .annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"annotation":63,"AT":67}

item set 115 
parExpression -> LPAREN .expression RPAREN
parExpression -> LPAREN .primitiveType RPAREN
parExpression -> LPAREN .qualifiedName arrayDimensionBrackl RPAREN
parExpression -> LPAREN .qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> LPAREN .qualifiedName typeParameters RPAREN
parExpression -> LPAREN .primitiveType arrayDimensionBrackl RPAREN
parExpression -> LPAREN .expression RPAREN
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":216,"primitiveType":217,"qualifiedName":218,"parExpression":98,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"Identifier":49,"LPAREN":115,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 116 
primitiveType -> BOOLEAN . 
transitions ->  {}

item set 117 
primitiveType -> CHAR . 
transitions ->  {}

item set 118 
primitiveType -> BYTE . 
transitions ->  {}

item set 119 
primitiveType -> SHORT . 
transitions ->  {}

item set 120 
primitiveType -> INT . 
transitions ->  {}

item set 121 
primitiveType -> LONG . 
transitions ->  {}

item set 122 
primitiveType -> FLOAT . 
transitions ->  {}

item set 123 
primitiveType -> DOUBLE . 
transitions ->  {}

item set 124 
newCreator -> NEW .creator
creator -> .nonWildcardTypeArguments createdName classCreatorRest
creator -> .createdName arrayOrClassCreator
nonWildcardTypeArguments -> .TEMPLATE
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"creator":219,"nonWildcardTypeArguments":220,"createdName":221,"TEMPLATE":131,"qualifiedName":222,"primitiveType":223,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 125 
plusMinusIncOrDec -> ADD . 
transitions ->  {}

item set 126 
plusMinusIncOrDec -> SUB . 
transitions ->  {}

item set 127 
plusMinusIncOrDec -> INC . 
transitions ->  {}

item set 128 
plusMinusIncOrDec -> DEC . 
transitions ->  {}

item set 129 
prefixTildeOrBang -> TILDE . 
transitions ->  {}

item set 130 
prefixTildeOrBang -> BANG . 
transitions ->  {}

item set 131 
nonWildcardTypeArguments -> TEMPLATE . 
transitions ->  {}

item set 132 
annotationTypeDeclaration -> AT INTERFACE Identifier annotationTypeBody . 
transitions ->  {}

item set 133 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS .typeList annotationTypeBody
typeList -> .type
typeList -> .typeList COMMA type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeList":224,"type":146,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 134 
annotationTypeBody -> LBRACE .RBRACE
annotationTypeBody -> LBRACE .annotationTypeElementDeclarations RBRACE
annotationTypeElementDeclarations -> .annotationTypeElementDeclaration
annotationTypeElementDeclarations -> .annotationTypeElementDeclarations annotationTypeElementDeclaration
annotationTypeElementDeclaration -> .modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .modifierL annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationTypeElementRest
annotationTypeElementDeclaration -> .SEMI
modifierL -> .modifier
modifierL -> .modifierL modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
annotationTypeElementRest -> .type annotationConstantRest SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest SEMI
annotationTypeElementRest -> .type annotationMethodRest SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":225,"annotationTypeElementDeclarations":226,"annotationTypeElementDeclaration":227,"modifierL":228,"annotationl":229,"annotationTypeElementRest":230,"SEMI":231,"modifier":15,"annotation":10,"type":232,"typeParameters":233,"classDeclaration":234,"interfaceDeclaration":235,"enumDeclaration":236,"annotationTypeDeclaration":237,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 135 
classDeclaration -> CLASS Identifier classInheritance interfaceImplentation .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":238,"LBRACE":239}

item set 136 
classDeclaration -> CLASS Identifier typeParameters classInheritance .interfaceImplentation classBody
interfaceImplentation -> .
interfaceImplentation -> .IMPLEMENTS typeList 
transitions ->  {"interfaceImplentation":240,"IMPLEMENTS":84}

item set 137 
classInheritance -> EXTENDS type . 
transitions ->  {}

item set 138 
type -> qualifiedName .arrayDimensionBracks
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":241,"DOT":69,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 139 
type -> primitiveType .arrayDimensionBracks
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":243,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 140 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters interfaceBody . 
transitions ->  {}

item set 141 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS .typeList interfaceBody
typeList -> .type
typeList -> .typeList COMMA type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeList":244,"type":146,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 142 
interfaceBody -> LBRACE .RBRACE
interfaceBody -> LBRACE .interfaceBodyDeclarationl RBRACE
interfaceBodyDeclarationl -> .interfaceBodyDeclaration
interfaceBodyDeclarationl -> .interfaceBodyDeclarationl interfaceBodyDeclaration
interfaceBodyDeclaration -> .annotationl modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .interfaceMemberDeclaration
interfaceBodyDeclaration -> .SEMI
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
interfaceMemberDeclaration -> .type constDelarators SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":245,"interfaceBodyDeclarationl":246,"interfaceBodyDeclaration":247,"annotationl":248,"modifierL":249,"interfaceMemberDeclaration":250,"SEMI":251,"annotation":10,"modifier":15,"type":252,"VOID":253,"typeParameters":254,"classDeclaration":255,"interfaceDeclaration":256,"enumDeclaration":257,"annotationTypeDeclaration":258,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 143 
enumDeclaration -> ENUM Identifier interfaceImplentation enumBody . 
transitions ->  {}

item set 144 
enumBody -> LBRACE .RBRACE
enumBody -> LBRACE .enumBodyDeclaration RBRACE
enumBodyDeclaration -> .enumConstants
enumBodyDeclaration -> .enumConstants COMMA
enumBodyDeclaration -> .enumConstants SEMI
enumBodyDeclaration -> .enumConstants COMMA SEMI
enumBodyDeclaration -> .enumConstants SEMI classBodyDeclarationl
enumBodyDeclaration -> .enumConstants COMMA SEMI classBodyDeclarationl
enumConstants -> .annotations Identifier enumConstantArguments enumConstantClassBody
enumConstants -> .enumConstants COMMA annotations Identifier enumConstantArguments enumConstantClassBody
annotations -> .
annotations -> .annotationl
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"RBRACE":259,"enumBodyDeclaration":260,"enumConstants":261,"annotations":262,"annotationl":114,"annotation":10,"AT":67}

item set 145 
interfaceImplentation -> IMPLEMENTS typeList .
typeList -> typeList .COMMA type 
transitions ->  {"COMMA":263}

item set 146 
typeList -> type . 
transitions ->  {}

item set 147 
qualifiedName -> qualifiedName DOT Identifier typeParameters . 
transitions ->  {}

item set 148 
importDeclaration -> IMPORT STATIC qualifiedName DOT MUL .SEMI 
transitions ->  {"SEMI":264}

item set 149 
importDeclaration -> IMPORT qualifiedName DOT MUL SEMI . 
transitions ->  {}

item set 150 
annotation -> AT qualifiedName LPAREN elementValueList RPAREN . 
transitions ->  {}

item set 151 
elementValueList -> elementValueList COMMA .elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValue":265,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 152 
annotation -> AT qualifiedName LPAREN elementValuePairs RPAREN . 
transitions ->  {}

item set 153 
elementValuePairs -> elementValuePairs COMMA .elementValuePair
elementValuePair -> .Identifier ASSIGN elementValue 
transitions ->  {"elementValuePair":266,"Identifier":267}

item set 154 
expression -> expression DOT .qualifiedName
expression -> expression DOT .SUPER
expression -> expression DOT .SUPER DOT expression
expression -> expression DOT .SUPER arguments
expression -> expression DOT .SUPER LPAREN RPAREN
expression -> expression DOT .newCreator
expression -> expression DOT .THIS
expression -> expression DOT .NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression DOT .qualifiedName
expression -> expression DOT .typeParameters Identifier arguments
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
newCreator -> .NEW creator
typeParameters -> .TEMPLATE 
transitions ->  {"qualifiedName":268,"SUPER":269,"newCreator":270,"THIS":271,"NEW":272,"typeParameters":273,"Identifier":49,"TEMPLATE":71}

item set 155 
expression -> expression LBRACK .expression RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":274,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 156 
expression -> expression arguments . 
transitions ->  {}

item set 157 
expression -> expression LPAREN .RPAREN
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":275,"expressionList":276,"expression":277,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 158 
expression -> expression incrementOrDecrement . 
transitions ->  {}

item set 159 
expression -> expression mulDivOrMod .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":278,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 160 
expression -> expression addOrSub .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":279,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 161 
expression -> expression LSHIFT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":280,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 162 
expression -> expression GT .GT expression
expression -> expression GT .GT GT expression
lE_GE_LT_GT -> GT . 
transitions ->  {"GT":281}

item set 163 
expression -> expression lE_GE_LT_GT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":282,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 164 
expression -> expression INSTANCEOF .type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":283,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 165 
expression -> expression equals_NotEqual .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":284,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 166 
expression -> expression BITAND .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":285,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 167 
expression -> expression CARET .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":286,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 168 
expression -> expression BITOR .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":287,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 169 
expression -> expression AND .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":288,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 170 
expression -> expression OR .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":289,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 171 
expression -> expression QUESTION .expression COLON expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":290,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 172 
expression -> expression assignmentToken .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":291,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 173 
incrementOrDecrement -> INC . 
transitions ->  {}

item set 174 
incrementOrDecrement -> DEC . 
transitions ->  {}

item set 175 
mulDivOrMod -> MUL . 
transitions ->  {}

item set 176 
mulDivOrMod -> DIV . 
transitions ->  {}

item set 177 
mulDivOrMod -> MOD . 
transitions ->  {}

item set 178 
addOrSub -> ADD . 
transitions ->  {}

item set 179 
addOrSub -> SUB . 
transitions ->  {}

item set 180 
lE_GE_LT_GT -> LE . 
transitions ->  {}

item set 181 
lE_GE_LT_GT -> GE . 
transitions ->  {}

item set 182 
lE_GE_LT_GT -> LT . 
transitions ->  {}

item set 183 
equals_NotEqual -> EQUAL . 
transitions ->  {}

item set 184 
equals_NotEqual -> NOTEQUAL . 
transitions ->  {}

item set 185 
assignmentToken -> ASSIGN . 
transitions ->  {}

item set 186 
assignmentToken -> ADD_ASSIGN . 
transitions ->  {}

item set 187 
assignmentToken -> SUB_ASSIGN . 
transitions ->  {}

item set 188 
assignmentToken -> MUL_ASSIGN . 
transitions ->  {}

item set 189 
assignmentToken -> DIV_ASSIGN . 
transitions ->  {}

item set 190 
assignmentToken -> AND_ASSIGN . 
transitions ->  {}

item set 191 
assignmentToken -> OR_ASSIGN . 
transitions ->  {}

item set 192 
assignmentToken -> XOR_ASSIGN . 
transitions ->  {}

item set 193 
assignmentToken -> RSHIFT_ASSIGN . 
transitions ->  {}

item set 194 
assignmentToken -> URSHIFT_ASSIGN . 
transitions ->  {}

item set 195 
assignmentToken -> LSHIFT_ASSIGN . 
transitions ->  {}

item set 196 
assignmentToken -> MOD_ASSIGN . 
transitions ->  {}

item set 197 
elementValue -> LBRACE RBRACE . 
transitions ->  {}

item set 198 
elementValue -> LBRACE elementValueList .RBRACE
elementValueList -> elementValueList .COMMA elementValue 
transitions ->  {"RBRACE":292,"COMMA":151}

item set 199 
elementValuePair -> Identifier ASSIGN .elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValue":293,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 200 
expression -> parExpression expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 201 
expression -> qualifiedName DOT .CLASS
expression -> qualifiedName DOT .SUPER
expression -> qualifiedName DOT .SUPER DOT expression
expression -> qualifiedName DOT .newCreator
expression -> qualifiedName DOT .THIS
expression -> qualifiedName DOT .explicitGenericInvocation
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters
newCreator -> .NEW creator
explicitGenericInvocation -> .nonWildcardTypeArguments explicitGenericInvocationSuffix
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"CLASS":294,"SUPER":295,"newCreator":296,"THIS":297,"explicitGenericInvocation":298,"Identifier":86,"NEW":124,"nonWildcardTypeArguments":299,"TEMPLATE":131}

item set 202 
expression -> qualifiedName arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":300,"arrayDimensionBrack":301,"LBRACK":207}

item set 203 
expression -> qualifiedName LBRACK .expression RBRACK
arrayDimensionBrack -> LBRACK .RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":302,"RBRACK":303,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 204 
arrayDimensionBrackl -> arrayDimensionBrack . 
transitions ->  {}

item set 205 
expression -> primitiveType DOT .CLASS 
transitions ->  {"CLASS":304}

item set 206 
expression -> primitiveType arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":305,"arrayDimensionBrack":301,"LBRACK":207}

item set 207 
arrayDimensionBrack -> LBRACK .RBRACK 
transitions ->  {"RBRACK":303}

item set 208 
expression -> plusMinusIncOrDec expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 209 
expression -> prefixTildeOrBang expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 210 
expression -> VOID DOT .CLASS 
transitions ->  {"CLASS":306}

item set 211 
expression -> nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs . 
transitions ->  {}

item set 212 
explicitGenericInvocationSuffixOrThisArgs -> explicitGenericInvocationSuffix . 
transitions ->  {}

item set 213 
explicitGenericInvocationSuffixOrThisArgs -> THIS .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":307,"LPAREN":308}

item set 214 
explicitGenericInvocationSuffix -> SUPER .superSuffix
superSuffix -> .arguments
superSuffix -> .DOT Identifier
superSuffix -> .DOT Identifier arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"superSuffix":309,"arguments":310,"DOT":311,"LPAREN":308}

item set 215 
explicitGenericInvocationSuffix -> Identifier .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":312,"LPAREN":308}

item set 216 
parExpression -> LPAREN expression .RPAREN
parExpression -> LPAREN expression .RPAREN
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":313,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 217 
parExpression -> LPAREN primitiveType .RPAREN
parExpression -> LPAREN primitiveType .arrayDimensionBrackl RPAREN
expression -> primitiveType .DOT CLASS
expression -> primitiveType .arrayDimensionBrackl DOT CLASS
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":314,"arrayDimensionBrackl":315,"DOT":205,"arrayDimensionBrack":204,"LBRACK":207}

item set 218 
parExpression -> LPAREN qualifiedName .arrayDimensionBrackl RPAREN
parExpression -> LPAREN qualifiedName .typeParameters arrayDimensionBrackl RPAREN
parExpression -> LPAREN qualifiedName .typeParameters RPAREN
expression -> qualifiedName .
expression -> qualifiedName .DOT CLASS
expression -> qualifiedName .DOT SUPER
expression -> qualifiedName .DOT SUPER DOT expression
expression -> qualifiedName .DOT newCreator
expression -> qualifiedName .arrayDimensionBrackl DOT CLASS
expression -> qualifiedName .DOT THIS
expression -> qualifiedName .DOT explicitGenericInvocation
expression -> qualifiedName .LBRACK expression RBRACK
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
typeParameters -> .TEMPLATE
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBrackl":316,"typeParameters":317,"DOT":201,"LBRACK":203,"arrayDimensionBrack":204,"TEMPLATE":71}

item set 219 
newCreator -> NEW creator . 
transitions ->  {}

item set 220 
creator -> nonWildcardTypeArguments .createdName classCreatorRest
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"createdName":318,"qualifiedName":222,"primitiveType":223,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 221 
creator -> createdName .arrayOrClassCreator
arrayOrClassCreator -> .arrayCreatorRest
arrayOrClassCreator -> .classCreatorRest
arrayCreatorRest -> .LBRACK RBRACK arrayDimensionBracks arrayInitializer
arrayCreatorRest -> .bracketedExpressions arrayDimensionBracks
classCreatorRest -> .arguments
classCreatorRest -> .LPAREN RPAREN
classCreatorRest -> .LPAREN RPAREN classBody
classCreatorRest -> .arguments classBody
bracketedExpressions -> .LBRACK expression RBRACK
bracketedExpressions -> .bracketedExpressions LBRACK expression RBRACK
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arrayOrClassCreator":319,"arrayCreatorRest":320,"classCreatorRest":321,"LBRACK":322,"bracketedExpressions":323,"arguments":324,"LPAREN":325}

item set 222 
createdName -> qualifiedName .optionalTypeArgumentsOrDiamonds
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
optionalTypeArgumentsOrDiamonds -> .
optionalTypeArgumentsOrDiamonds -> .typeArgumentsOrDiamondList
typeArgumentsOrDiamondList -> .typeArgumentsOrDiamond
typeArgumentsOrDiamondList -> .typeArgumentsOrDiamondList DOT Identifier typeArgumentsOrDiamond
typeArgumentsOrDiamond -> .LT GT
typeArgumentsOrDiamond -> .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"optionalTypeArgumentsOrDiamonds":326,"DOT":69,"typeArgumentsOrDiamondList":327,"typeArgumentsOrDiamond":328,"LT":329,"typeParameters":330,"TEMPLATE":71}

item set 223 
createdName -> primitiveType . 
transitions ->  {}

item set 224 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS typeList .annotationTypeBody
typeList -> typeList .COMMA type
annotationTypeBody -> .LBRACE RBRACE
annotationTypeBody -> .LBRACE annotationTypeElementDeclarations RBRACE 
transitions ->  {"annotationTypeBody":331,"COMMA":263,"LBRACE":134}

item set 225 
annotationTypeBody -> LBRACE RBRACE . 
transitions ->  {}

item set 226 
annotationTypeBody -> LBRACE annotationTypeElementDeclarations .RBRACE
annotationTypeElementDeclarations -> annotationTypeElementDeclarations .annotationTypeElementDeclaration
annotationTypeElementDeclaration -> .modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .modifierL annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationTypeElementRest
annotationTypeElementDeclaration -> .SEMI
modifierL -> .modifier
modifierL -> .modifierL modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
annotationTypeElementRest -> .type annotationConstantRest SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest SEMI
annotationTypeElementRest -> .type annotationMethodRest SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":332,"annotationTypeElementDeclaration":333,"modifierL":228,"annotationl":229,"annotationTypeElementRest":230,"SEMI":231,"modifier":15,"annotation":10,"type":232,"typeParameters":233,"classDeclaration":234,"interfaceDeclaration":235,"enumDeclaration":236,"annotationTypeDeclaration":237,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 227 
annotationTypeElementDeclarations -> annotationTypeElementDeclaration . 
transitions ->  {}

item set 228 
annotationTypeElementDeclaration -> modifierL .annotationTypeElementRest
annotationTypeElementDeclaration -> modifierL .annotationl annotationTypeElementRest
modifierL -> modifierL .modifier
annotationTypeElementRest -> .type annotationConstantRest SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest SEMI
annotationTypeElementRest -> .type annotationMethodRest SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":334,"annotationl":335,"modifier":54,"type":232,"typeParameters":233,"classDeclaration":234,"interfaceDeclaration":235,"enumDeclaration":236,"annotationTypeDeclaration":237,"annotation":10,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":14,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 229 
annotationTypeElementDeclaration -> annotationl .annotationTypeElementRest
annotationTypeElementDeclaration -> annotationl .modifierL annotationTypeElementRest
annotationl -> annotationl .annotation
annotationTypeElementRest -> .type annotationConstantRest SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest SEMI
annotationTypeElementRest -> .type annotationMethodRest SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifierL -> .modifier
modifierL -> .modifierL modifier
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":336,"modifierL":337,"annotation":63,"type":232,"typeParameters":233,"classDeclaration":234,"interfaceDeclaration":235,"enumDeclaration":236,"annotationTypeDeclaration":237,"modifier":15,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 230 
annotationTypeElementDeclaration -> annotationTypeElementRest . 
transitions ->  {}

item set 231 
annotationTypeElementDeclaration -> SEMI . 
transitions ->  {}

item set 232 
annotationTypeElementRest -> type .annotationConstantRest SEMI
annotationTypeElementRest -> type .annotationMethodRest SEMI
annotationConstantRest -> .variableDeclarators
annotationMethodRest -> .Identifier LPAREN RPAREN defaultValue
annotationMethodRest -> .Identifier LPAREN RPAREN
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"annotationConstantRest":338,"annotationMethodRest":339,"variableDeclarators":340,"Identifier":341,"variableDeclarator":342,"variableDeclaratorId":343}

item set 233 
annotationTypeElementRest -> typeParameters .type annotationMethodRest SEMI
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":344,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 234 
annotationTypeElementRest -> classDeclaration . 
transitions ->  {}

item set 235 
annotationTypeElementRest -> interfaceDeclaration . 
transitions ->  {}

item set 236 
annotationTypeElementRest -> enumDeclaration . 
transitions ->  {}

item set 237 
annotationTypeElementRest -> annotationTypeDeclaration . 
transitions ->  {}

item set 238 
classDeclaration -> CLASS Identifier classInheritance interfaceImplentation classBody . 
transitions ->  {}

item set 239 
classBody -> LBRACE .RBRACE
classBody -> LBRACE .classBodyDeclarationl RBRACE
classBodyDeclarationl -> .classBodyDeclaration
classBodyDeclarationl -> .classBodyDeclarationl classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":345,"classBodyDeclarationl":346,"classBodyDeclaration":347,"SEMI":348,"annotationl":349,"modifierL":350,"classMemberDeclaration":351,"classStaticBlock":352,"annotation":10,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":361,"block":362,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":363,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 240 
classDeclaration -> CLASS Identifier typeParameters classInheritance interfaceImplentation .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":364,"LBRACE":239}

item set 241 
type -> qualifiedName arrayDimensionBracks . 
transitions ->  {}

item set 242 
arrayDimensionBracks -> arrayDimensionBrackl .
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBrack":301,"LBRACK":207}

item set 243 
type -> primitiveType arrayDimensionBracks . 
transitions ->  {}

item set 244 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS typeList .interfaceBody
typeList -> typeList .COMMA type
interfaceBody -> .LBRACE RBRACE
interfaceBody -> .LBRACE interfaceBodyDeclarationl RBRACE 
transitions ->  {"interfaceBody":365,"COMMA":263,"LBRACE":142}

item set 245 
interfaceBody -> LBRACE RBRACE . 
transitions ->  {}

item set 246 
interfaceBody -> LBRACE interfaceBodyDeclarationl .RBRACE
interfaceBodyDeclarationl -> interfaceBodyDeclarationl .interfaceBodyDeclaration
interfaceBodyDeclaration -> .annotationl modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .interfaceMemberDeclaration
interfaceBodyDeclaration -> .SEMI
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
interfaceMemberDeclaration -> .type constDelarators SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":366,"interfaceBodyDeclaration":367,"annotationl":248,"modifierL":249,"interfaceMemberDeclaration":250,"SEMI":251,"annotation":10,"modifier":15,"type":252,"VOID":253,"typeParameters":254,"classDeclaration":255,"interfaceDeclaration":256,"enumDeclaration":257,"annotationTypeDeclaration":258,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 247 
interfaceBodyDeclarationl -> interfaceBodyDeclaration . 
transitions ->  {}

item set 248 
interfaceBodyDeclaration -> annotationl .modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> annotationl .interfaceMemberDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
interfaceMemberDeclaration -> .type constDelarators SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":368,"interfaceMemberDeclaration":369,"annotation":63,"modifier":15,"type":252,"VOID":253,"typeParameters":254,"classDeclaration":255,"interfaceDeclaration":256,"enumDeclaration":257,"annotationTypeDeclaration":258,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 249 
interfaceBodyDeclaration -> modifierL .annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> modifierL .interfaceMemberDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
interfaceMemberDeclaration -> .type constDelarators SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationl":370,"interfaceMemberDeclaration":371,"modifier":54,"annotation":10,"type":252,"VOID":253,"typeParameters":254,"classDeclaration":255,"interfaceDeclaration":256,"enumDeclaration":257,"annotationTypeDeclaration":258,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 250 
interfaceBodyDeclaration -> interfaceMemberDeclaration . 
transitions ->  {}

item set 251 
interfaceBodyDeclaration -> SEMI . 
transitions ->  {}

item set 252 
interfaceMemberDeclaration -> type .constDelarators SEMI
interfaceMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> type .Identifier formalParameters SEMI
constDelarators -> .constantDeclarator
constDelarators -> .constDelarators COMMA constantDeclarator
constantDeclarator -> .Identifier ASSIGN variableInitializer
constantDeclarator -> .Identifier arrayDimensionBrackl ASSIGN variableInitializer 
transitions ->  {"constDelarators":372,"Identifier":373,"constantDeclarator":374}

item set 253 
interfaceMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> VOID .Identifier formalParameters SEMI 
transitions ->  {"Identifier":375}

item set 254 
interfaceMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters .type Identifier formalParameters SEMI
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"VOID":376,"type":377,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 255 
interfaceMemberDeclaration -> classDeclaration . 
transitions ->  {}

item set 256 
interfaceMemberDeclaration -> interfaceDeclaration . 
transitions ->  {}

item set 257 
interfaceMemberDeclaration -> enumDeclaration . 
transitions ->  {}

item set 258 
interfaceMemberDeclaration -> annotationTypeDeclaration . 
transitions ->  {}

item set 259 
enumBody -> LBRACE RBRACE . 
transitions ->  {}

item set 260 
enumBody -> LBRACE enumBodyDeclaration .RBRACE 
transitions ->  {"RBRACE":378}

item set 261 
enumBodyDeclaration -> enumConstants .
enumBodyDeclaration -> enumConstants .COMMA
enumBodyDeclaration -> enumConstants .SEMI
enumBodyDeclaration -> enumConstants .COMMA SEMI
enumBodyDeclaration -> enumConstants .SEMI classBodyDeclarationl
enumBodyDeclaration -> enumConstants .COMMA SEMI classBodyDeclarationl
enumConstants -> enumConstants .COMMA annotations Identifier enumConstantArguments enumConstantClassBody 
transitions ->  {"COMMA":379,"SEMI":380}

item set 262 
enumConstants -> annotations .Identifier enumConstantArguments enumConstantClassBody 
transitions ->  {"Identifier":381}

item set 263 
typeList -> typeList COMMA .type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":382,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 264 
importDeclaration -> IMPORT STATIC qualifiedName DOT MUL SEMI . 
transitions ->  {}

item set 265 
elementValueList -> elementValueList COMMA elementValue . 
transitions ->  {}

item set 266 
elementValuePairs -> elementValuePairs COMMA elementValuePair . 
transitions ->  {}

item set 267 
elementValuePair -> Identifier .ASSIGN elementValue 
transitions ->  {"ASSIGN":199}

item set 268 
expression -> expression DOT qualifiedName .
expression -> expression DOT qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 269 
expression -> expression DOT SUPER .
expression -> expression DOT SUPER .DOT expression
expression -> expression DOT SUPER .arguments
expression -> expression DOT SUPER .LPAREN RPAREN
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"DOT":383,"arguments":384,"LPAREN":385}

item set 270 
expression -> expression DOT newCreator . 
transitions ->  {}

item set 271 
expression -> expression DOT THIS . 
transitions ->  {}

item set 272 
expression -> expression DOT NEW .optionalNonWildcardTypeArguments innerCreator
newCreator -> NEW .creator
optionalNonWildcardTypeArguments -> .
optionalNonWildcardTypeArguments -> .nonWildcardTypeArguments
creator -> .nonWildcardTypeArguments createdName classCreatorRest
creator -> .createdName arrayOrClassCreator
nonWildcardTypeArguments -> .TEMPLATE
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"optionalNonWildcardTypeArguments":386,"creator":219,"nonWildcardTypeArguments":387,"createdName":221,"TEMPLATE":131,"qualifiedName":222,"primitiveType":223,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 273 
expression -> expression DOT typeParameters .Identifier arguments 
transitions ->  {"Identifier":388}

item set 274 
expression -> expression LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":389,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 275 
expression -> expression LPAREN RPAREN .
arguments -> LPAREN RPAREN . 
transitions ->  {}

item set 276 
arguments -> LPAREN expressionList .RPAREN
expressionList -> expressionList .COMMA expression 
transitions ->  {"RPAREN":390,"COMMA":391}

item set 277 
expressionList -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 278 
expression -> expression mulDivOrMod expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 279 
expression -> expression addOrSub expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 280 
expression -> expression LSHIFT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 281 
expression -> expression GT GT .expression
expression -> expression GT GT .GT expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":392,"GT":393,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 282 
expression -> expression lE_GE_LT_GT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 283 
expression -> expression INSTANCEOF type . 
transitions ->  {}

item set 284 
expression -> expression equals_NotEqual expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 285 
expression -> expression BITAND expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 286 
expression -> expression CARET expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 287 
expression -> expression BITOR expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 288 
expression -> expression AND expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 289 
expression -> expression OR expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 290 
expression -> expression QUESTION expression .COLON expression
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"COLON":394,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 291 
expression -> expression assignmentToken expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 292 
elementValue -> LBRACE elementValueList RBRACE . 
transitions ->  {}

item set 293 
elementValuePair -> Identifier ASSIGN elementValue . 
transitions ->  {}

item set 294 
expression -> qualifiedName DOT CLASS . 
transitions ->  {}

item set 295 
expression -> qualifiedName DOT SUPER .
expression -> qualifiedName DOT SUPER .DOT expression 
transitions ->  {"DOT":395}

item set 296 
expression -> qualifiedName DOT newCreator . 
transitions ->  {}

item set 297 
expression -> qualifiedName DOT THIS . 
transitions ->  {}

item set 298 
expression -> qualifiedName DOT explicitGenericInvocation . 
transitions ->  {}

item set 299 
explicitGenericInvocation -> nonWildcardTypeArguments .explicitGenericInvocationSuffix
explicitGenericInvocationSuffix -> .SUPER superSuffix
explicitGenericInvocationSuffix -> .Identifier arguments 
transitions ->  {"explicitGenericInvocationSuffix":396,"SUPER":214,"Identifier":215}

item set 300 
expression -> qualifiedName arrayDimensionBrackl DOT .CLASS 
transitions ->  {"CLASS":397}

item set 301 
arrayDimensionBrackl -> arrayDimensionBrackl arrayDimensionBrack . 
transitions ->  {}

item set 302 
expression -> qualifiedName LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":398,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 303 
arrayDimensionBrack -> LBRACK RBRACK . 
transitions ->  {}

item set 304 
expression -> primitiveType DOT CLASS . 
transitions ->  {}

item set 305 
expression -> primitiveType arrayDimensionBrackl DOT .CLASS 
transitions ->  {"CLASS":399}

item set 306 
expression -> VOID DOT CLASS . 
transitions ->  {}

item set 307 
explicitGenericInvocationSuffixOrThisArgs -> THIS arguments . 
transitions ->  {}

item set 308 
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":400,"expressionList":276,"expression":277,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 309 
explicitGenericInvocationSuffix -> SUPER superSuffix . 
transitions ->  {}

item set 310 
superSuffix -> arguments . 
transitions ->  {}

item set 311 
superSuffix -> DOT .Identifier
superSuffix -> DOT .Identifier arguments 
transitions ->  {"Identifier":401}

item set 312 
explicitGenericInvocationSuffix -> Identifier arguments . 
transitions ->  {}

item set 313 
parExpression -> LPAREN expression RPAREN .
parExpression -> LPAREN expression RPAREN . 
transitions ->  {}

item set 314 
parExpression -> LPAREN primitiveType RPAREN . 
transitions ->  {}

item set 315 
parExpression -> LPAREN primitiveType arrayDimensionBrackl .RPAREN
expression -> primitiveType arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":402,"DOT":305,"arrayDimensionBrack":301,"LBRACK":207}

item set 316 
parExpression -> LPAREN qualifiedName arrayDimensionBrackl .RPAREN
expression -> qualifiedName arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":403,"DOT":300,"arrayDimensionBrack":301,"LBRACK":207}

item set 317 
parExpression -> LPAREN qualifiedName typeParameters .arrayDimensionBrackl RPAREN
parExpression -> LPAREN qualifiedName typeParameters .RPAREN
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBrackl":404,"RPAREN":405,"arrayDimensionBrack":204,"LBRACK":207}

item set 318 
creator -> nonWildcardTypeArguments createdName .classCreatorRest
classCreatorRest -> .arguments
classCreatorRest -> .LPAREN RPAREN
classCreatorRest -> .LPAREN RPAREN classBody
classCreatorRest -> .arguments classBody
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"classCreatorRest":406,"arguments":324,"LPAREN":325}

item set 319 
creator -> createdName arrayOrClassCreator . 
transitions ->  {}

item set 320 
arrayOrClassCreator -> arrayCreatorRest . 
transitions ->  {}

item set 321 
arrayOrClassCreator -> classCreatorRest . 
transitions ->  {}

item set 322 
arrayCreatorRest -> LBRACK .RBRACK arrayDimensionBracks arrayInitializer
bracketedExpressions -> LBRACK .expression RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RBRACK":407,"expression":408,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 323 
arrayCreatorRest -> bracketedExpressions .arrayDimensionBracks
bracketedExpressions -> bracketedExpressions .LBRACK expression RBRACK
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":409,"LBRACK":410,"arrayDimensionBrackl":242,"arrayDimensionBrack":204}

item set 324 
classCreatorRest -> arguments .
classCreatorRest -> arguments .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":411,"LBRACE":239}

item set 325 
classCreatorRest -> LPAREN .RPAREN
classCreatorRest -> LPAREN .RPAREN classBody
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":412,"expressionList":276,"expression":277,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 326 
createdName -> qualifiedName optionalTypeArgumentsOrDiamonds . 
transitions ->  {}

item set 327 
optionalTypeArgumentsOrDiamonds -> typeArgumentsOrDiamondList .
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList .DOT Identifier typeArgumentsOrDiamond 
transitions ->  {"DOT":413}

item set 328 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamond . 
transitions ->  {}

item set 329 
typeArgumentsOrDiamond -> LT .GT 
transitions ->  {"GT":414}

item set 330 
typeArgumentsOrDiamond -> typeParameters . 
transitions ->  {}

item set 331 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS typeList annotationTypeBody . 
transitions ->  {}

item set 332 
annotationTypeBody -> LBRACE annotationTypeElementDeclarations RBRACE . 
transitions ->  {}

item set 333 
annotationTypeElementDeclarations -> annotationTypeElementDeclarations annotationTypeElementDeclaration . 
transitions ->  {}

item set 334 
annotationTypeElementDeclaration -> modifierL annotationTypeElementRest . 
transitions ->  {}

item set 335 
annotationTypeElementDeclaration -> modifierL annotationl .annotationTypeElementRest
annotationl -> annotationl .annotation
annotationTypeElementRest -> .type annotationConstantRest SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest SEMI
annotationTypeElementRest -> .type annotationMethodRest SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":415,"annotation":63,"type":232,"typeParameters":233,"classDeclaration":234,"interfaceDeclaration":235,"enumDeclaration":236,"annotationTypeDeclaration":237,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 336 
annotationTypeElementDeclaration -> annotationl annotationTypeElementRest . 
transitions ->  {}

item set 337 
annotationTypeElementDeclaration -> annotationl modifierL .annotationTypeElementRest
modifierL -> modifierL .modifier
annotationTypeElementRest -> .type annotationConstantRest SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest SEMI
annotationTypeElementRest -> .type annotationMethodRest SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":416,"modifier":54,"type":232,"typeParameters":233,"classDeclaration":234,"interfaceDeclaration":235,"enumDeclaration":236,"annotationTypeDeclaration":237,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 338 
annotationTypeElementRest -> type annotationConstantRest .SEMI 
transitions ->  {"SEMI":417}

item set 339 
annotationTypeElementRest -> type annotationMethodRest .SEMI 
transitions ->  {"SEMI":418}

item set 340 
annotationConstantRest -> variableDeclarators .
variableDeclarators -> variableDeclarators .COMMA variableDeclarator 
transitions ->  {"COMMA":419}

item set 341 
annotationMethodRest -> Identifier .LPAREN RPAREN defaultValue
annotationMethodRest -> Identifier .LPAREN RPAREN
variableDeclaratorId -> Identifier .arrayDimensionBracks
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"LPAREN":420,"arrayDimensionBracks":421,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 342 
variableDeclarators -> variableDeclarator . 
transitions ->  {}

item set 343 
variableDeclarator -> variableDeclaratorId .
variableDeclarator -> variableDeclaratorId .ASSIGN variableInitializer 
transitions ->  {"ASSIGN":422}

item set 344 
annotationTypeElementRest -> typeParameters type .annotationMethodRest SEMI
annotationMethodRest -> .Identifier LPAREN RPAREN defaultValue
annotationMethodRest -> .Identifier LPAREN RPAREN 
transitions ->  {"annotationMethodRest":423,"Identifier":424}

item set 345 
classBody -> LBRACE RBRACE . 
transitions ->  {}

item set 346 
classBody -> LBRACE classBodyDeclarationl .RBRACE
classBodyDeclarationl -> classBodyDeclarationl .classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":425,"classBodyDeclaration":426,"SEMI":348,"annotationl":349,"modifierL":350,"classMemberDeclaration":351,"classStaticBlock":352,"annotation":10,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":361,"block":362,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":363,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 347 
classBodyDeclarationl -> classBodyDeclaration . 
transitions ->  {}

item set 348 
classBodyDeclaration -> SEMI . 
transitions ->  {}

item set 349 
classBodyDeclaration -> annotationl .modifierL classMemberDeclaration
classBodyDeclaration -> annotationl .classMemberDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":427,"classMemberDeclaration":428,"annotation":63,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 350 
classBodyDeclaration -> modifierL .annotationl classMemberDeclaration
classBodyDeclaration -> modifierL .classMemberDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationl":429,"classMemberDeclaration":430,"modifier":54,"annotation":10,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 351 
classBodyDeclaration -> classMemberDeclaration . 
transitions ->  {}

item set 352 
classBodyDeclaration -> classStaticBlock . 
transitions ->  {}

item set 353 
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> VOID .Identifier formalParameters block
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> VOID .Identifier formalParameters SEMI 
transitions ->  {"Identifier":431}

item set 354 
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> type .Identifier formalParameters block
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> type .Identifier formalParameters SEMI
classMemberDeclaration -> type .variableDeclarators SEMI
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"Identifier":432,"variableDeclarators":433,"variableDeclarator":342,"variableDeclaratorId":343}

item set 355 
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters block
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> typeParameters .type Identifier formalParameters block
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters SEMI
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters .type Identifier formalParameters SEMI
classMemberDeclaration -> typeParameters .Identifier formalParameters throwsList block
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"VOID":434,"type":435,"Identifier":436,"qualifiedName":138,"primitiveType":139,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 356 
classMemberDeclaration -> Identifier .formalParameters throwsList block
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
typeParameters -> .TEMPLATE 
transitions ->  {"formalParameters":437,"typeParameters":70,"LPAREN":438,"TEMPLATE":71}

item set 357 
classMemberDeclaration -> classDeclaration . 
transitions ->  {}

item set 358 
classMemberDeclaration -> interfaceDeclaration . 
transitions ->  {}

item set 359 
classMemberDeclaration -> enumDeclaration . 
transitions ->  {}

item set 360 
classMemberDeclaration -> annotationTypeDeclaration . 
transitions ->  {}

item set 361 
classStaticBlock -> STATIC .block
modifier -> STATIC .
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":439,"LBRACE":363}

item set 362 
classStaticBlock -> block . 
transitions ->  {}

item set 363 
block -> LBRACE .RBRACE
block -> LBRACE .blockStatementList RBRACE
blockStatementList -> .blockStatement
blockStatementList -> .blockStatementList blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":440,"blockStatementList":441,"blockStatement":442,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 364 
classDeclaration -> CLASS Identifier typeParameters classInheritance interfaceImplentation classBody . 
transitions ->  {}

item set 365 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody . 
transitions ->  {}

item set 366 
interfaceBody -> LBRACE interfaceBodyDeclarationl RBRACE . 
transitions ->  {}

item set 367 
interfaceBodyDeclarationl -> interfaceBodyDeclarationl interfaceBodyDeclaration . 
transitions ->  {}

item set 368 
interfaceBodyDeclaration -> annotationl modifierL .interfaceMemberDeclaration
modifierL -> modifierL .modifier
interfaceMemberDeclaration -> .type constDelarators SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"interfaceMemberDeclaration":467,"modifier":54,"type":252,"VOID":253,"typeParameters":254,"classDeclaration":255,"interfaceDeclaration":256,"enumDeclaration":257,"annotationTypeDeclaration":258,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 369 
interfaceBodyDeclaration -> annotationl interfaceMemberDeclaration . 
transitions ->  {}

item set 370 
interfaceBodyDeclaration -> modifierL annotationl .interfaceMemberDeclaration
annotationl -> annotationl .annotation
interfaceMemberDeclaration -> .type constDelarators SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"interfaceMemberDeclaration":468,"annotation":63,"type":252,"VOID":253,"typeParameters":254,"classDeclaration":255,"interfaceDeclaration":256,"enumDeclaration":257,"annotationTypeDeclaration":258,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 371 
interfaceBodyDeclaration -> modifierL interfaceMemberDeclaration . 
transitions ->  {}

item set 372 
interfaceMemberDeclaration -> type constDelarators .SEMI
constDelarators -> constDelarators .COMMA constantDeclarator 
transitions ->  {"SEMI":469,"COMMA":470}

item set 373 
interfaceMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> type Identifier .formalParameters SEMI
constantDeclarator -> Identifier .ASSIGN variableInitializer
constantDeclarator -> Identifier .arrayDimensionBrackl ASSIGN variableInitializer
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"formalParameters":471,"ASSIGN":472,"arrayDimensionBrackl":473,"LPAREN":438,"arrayDimensionBrack":204,"LBRACK":207}

item set 374 
constDelarators -> constantDeclarator . 
transitions ->  {}

item set 375 
interfaceMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> VOID Identifier .formalParameters SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":474,"LPAREN":438}

item set 376 
interfaceMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters VOID .Identifier formalParameters SEMI 
transitions ->  {"Identifier":475}

item set 377 
interfaceMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters type .Identifier formalParameters SEMI 
transitions ->  {"Identifier":476}

item set 378 
enumBody -> LBRACE enumBodyDeclaration RBRACE . 
transitions ->  {}

item set 379 
enumBodyDeclaration -> enumConstants COMMA .
enumBodyDeclaration -> enumConstants COMMA .SEMI
enumBodyDeclaration -> enumConstants COMMA .SEMI classBodyDeclarationl
enumConstants -> enumConstants COMMA .annotations Identifier enumConstantArguments enumConstantClassBody
annotations -> .
annotations -> .annotationl
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"SEMI":477,"annotations":478,"annotationl":114,"annotation":10,"AT":67}

item set 380 
enumBodyDeclaration -> enumConstants SEMI .
enumBodyDeclaration -> enumConstants SEMI .classBodyDeclarationl
classBodyDeclarationl -> .classBodyDeclaration
classBodyDeclarationl -> .classBodyDeclarationl classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclarationl":479,"classBodyDeclaration":347,"SEMI":348,"annotationl":349,"modifierL":350,"classMemberDeclaration":351,"classStaticBlock":352,"annotation":10,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":361,"block":362,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":363,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 381 
enumConstants -> annotations Identifier .enumConstantArguments enumConstantClassBody
enumConstantArguments -> .
enumConstantArguments -> .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"enumConstantArguments":480,"arguments":481,"LPAREN":308}

item set 382 
typeList -> typeList COMMA type . 
transitions ->  {}

item set 383 
expression -> expression DOT SUPER DOT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":482,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 384 
expression -> expression DOT SUPER arguments . 
transitions ->  {}

item set 385 
expression -> expression DOT SUPER LPAREN .RPAREN
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":483,"expressionList":276,"expression":277,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 386 
expression -> expression DOT NEW optionalNonWildcardTypeArguments .innerCreator
innerCreator -> .Identifier optionalNonWildcardTypeArgumentsOrDiamond classCreatorRest 
transitions ->  {"innerCreator":484,"Identifier":485}

item set 387 
optionalNonWildcardTypeArguments -> nonWildcardTypeArguments .
creator -> nonWildcardTypeArguments .createdName classCreatorRest
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"createdName":318,"qualifiedName":222,"primitiveType":223,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 388 
expression -> expression DOT typeParameters Identifier .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":486,"LPAREN":308}

item set 389 
expression -> expression LBRACK expression RBRACK . 
transitions ->  {}

item set 390 
arguments -> LPAREN expressionList RPAREN . 
transitions ->  {}

item set 391 
expressionList -> expressionList COMMA .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":487,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 392 
expression -> expression GT GT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 393 
expression -> expression GT GT GT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":488,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 394 
expression -> expression QUESTION expression COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":489,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 395 
expression -> qualifiedName DOT SUPER DOT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":490,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 396 
explicitGenericInvocation -> nonWildcardTypeArguments explicitGenericInvocationSuffix . 
transitions ->  {}

item set 397 
expression -> qualifiedName arrayDimensionBrackl DOT CLASS . 
transitions ->  {}

item set 398 
expression -> qualifiedName LBRACK expression RBRACK . 
transitions ->  {}

item set 399 
expression -> primitiveType arrayDimensionBrackl DOT CLASS . 
transitions ->  {}

item set 400 
arguments -> LPAREN RPAREN . 
transitions ->  {}

item set 401 
superSuffix -> DOT Identifier .
superSuffix -> DOT Identifier .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":491,"LPAREN":308}

item set 402 
parExpression -> LPAREN primitiveType arrayDimensionBrackl RPAREN . 
transitions ->  {}

item set 403 
parExpression -> LPAREN qualifiedName arrayDimensionBrackl RPAREN . 
transitions ->  {}

item set 404 
parExpression -> LPAREN qualifiedName typeParameters arrayDimensionBrackl .RPAREN
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":492,"arrayDimensionBrack":301,"LBRACK":207}

item set 405 
parExpression -> LPAREN qualifiedName typeParameters RPAREN . 
transitions ->  {}

item set 406 
creator -> nonWildcardTypeArguments createdName classCreatorRest . 
transitions ->  {}

item set 407 
arrayCreatorRest -> LBRACK RBRACK .arrayDimensionBracks arrayInitializer
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":493,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 408 
bracketedExpressions -> LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":494,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 409 
arrayCreatorRest -> bracketedExpressions arrayDimensionBracks . 
transitions ->  {}

item set 410 
bracketedExpressions -> bracketedExpressions LBRACK .expression RBRACK
arrayDimensionBrack -> LBRACK .RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":495,"RBRACK":303,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 411 
classCreatorRest -> arguments classBody . 
transitions ->  {}

item set 412 
classCreatorRest -> LPAREN RPAREN .
classCreatorRest -> LPAREN RPAREN .classBody
arguments -> LPAREN RPAREN .
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":496,"LBRACE":239}

item set 413 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList DOT .Identifier typeArgumentsOrDiamond 
transitions ->  {"Identifier":497}

item set 414 
typeArgumentsOrDiamond -> LT GT . 
transitions ->  {}

item set 415 
annotationTypeElementDeclaration -> modifierL annotationl annotationTypeElementRest . 
transitions ->  {}

item set 416 
annotationTypeElementDeclaration -> annotationl modifierL annotationTypeElementRest . 
transitions ->  {}

item set 417 
annotationTypeElementRest -> type annotationConstantRest SEMI . 
transitions ->  {}

item set 418 
annotationTypeElementRest -> type annotationMethodRest SEMI . 
transitions ->  {}

item set 419 
variableDeclarators -> variableDeclarators COMMA .variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclarator":498,"variableDeclaratorId":343,"Identifier":499}

item set 420 
annotationMethodRest -> Identifier LPAREN .RPAREN defaultValue
annotationMethodRest -> Identifier LPAREN .RPAREN 
transitions ->  {"RPAREN":500}

item set 421 
variableDeclaratorId -> Identifier arrayDimensionBracks . 
transitions ->  {}

item set 422 
variableDeclarator -> variableDeclaratorId ASSIGN .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"variableInitializer":501,"arrayInitializer":502,"expression":503,"LBRACE":504,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 423 
annotationTypeElementRest -> typeParameters type annotationMethodRest .SEMI 
transitions ->  {"SEMI":505}

item set 424 
annotationMethodRest -> Identifier .LPAREN RPAREN defaultValue
annotationMethodRest -> Identifier .LPAREN RPAREN 
transitions ->  {"LPAREN":420}

item set 425 
classBody -> LBRACE classBodyDeclarationl RBRACE . 
transitions ->  {}

item set 426 
classBodyDeclarationl -> classBodyDeclarationl classBodyDeclaration . 
transitions ->  {}

item set 427 
classBodyDeclaration -> annotationl modifierL .classMemberDeclaration
modifierL -> modifierL .modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classMemberDeclaration":506,"modifier":54,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 428 
classBodyDeclaration -> annotationl classMemberDeclaration . 
transitions ->  {}

item set 429 
classBodyDeclaration -> modifierL annotationl .classMemberDeclaration
annotationl -> annotationl .annotation
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classMemberDeclaration":507,"annotation":63,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"AT":14,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 430 
classBodyDeclaration -> modifierL classMemberDeclaration . 
transitions ->  {}

item set 431 
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks block
classMemberDeclaration -> VOID Identifier .formalParameters block
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> VOID Identifier .formalParameters SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":508,"LPAREN":438}

item set 432 
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks block
classMemberDeclaration -> type Identifier .formalParameters block
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> type Identifier .formalParameters SEMI
variableDeclaratorId -> Identifier .arrayDimensionBracks
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"formalParameters":509,"arrayDimensionBracks":421,"LPAREN":438,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 433 
classMemberDeclaration -> type variableDeclarators .SEMI
variableDeclarators -> variableDeclarators .COMMA variableDeclarator 
transitions ->  {"SEMI":510,"COMMA":419}

item set 434 
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters block
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters SEMI 
transitions ->  {"Identifier":511}

item set 435 
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> typeParameters type .Identifier formalParameters block
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters type .Identifier formalParameters SEMI 
transitions ->  {"Identifier":512}

item set 436 
classMemberDeclaration -> typeParameters Identifier .formalParameters throwsList block
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
typeParameters -> .TEMPLATE 
transitions ->  {"formalParameters":513,"typeParameters":70,"LPAREN":438,"TEMPLATE":71}

item set 437 
classMemberDeclaration -> Identifier formalParameters .throwsList block
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":514,"THROWS":515}

item set 438 
formalParameters -> LPAREN .RPAREN
formalParameters -> LPAREN .formalParameterList RPAREN
formalParameterList -> .usualParameterList
formalParameterList -> .usualParameterList COMMA lastFormalParameter
formalParameterList -> .lastFormalParameter
usualParameterList -> .usualParameter
usualParameterList -> .usualParameterList COMMA usualParameter
lastFormalParameter -> .variableModifiers type ELLIPSIS variableDeclaratorId
lastFormalParameter -> .type ELLIPSIS variableDeclaratorId
usualParameter -> .variableModifiers type variableDeclaratorId
usualParameter -> .type variableDeclaratorId
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"RPAREN":516,"formalParameterList":517,"usualParameterList":518,"lastFormalParameter":519,"usualParameter":520,"variableModifiers":521,"type":522,"FINAL":523,"annotationl":524,"qualifiedName":138,"primitiveType":139,"annotation":10,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"AT":67}

item set 439 
classStaticBlock -> STATIC block . 
transitions ->  {}

item set 440 
block -> LBRACE RBRACE . 
transitions ->  {}

item set 441 
block -> LBRACE blockStatementList .RBRACE
blockStatementList -> blockStatementList .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":525,"blockStatement":526,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 442 
blockStatementList -> blockStatement . 
transitions ->  {}

item set 443 
blockStatement -> statement . 
transitions ->  {}

item set 444 
blockStatement -> LBRACE .RBRACE
blockStatement -> LBRACE .blockStatementList RBRACE
blockStatementList -> .blockStatement
blockStatementList -> .blockStatementList blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":527,"blockStatementList":528,"blockStatement":442,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 445 
statement -> ASSERT .assertExpression SEMI
assertExpression -> .expression
assertExpression -> .expression COLON expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"assertExpression":529,"expression":530,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 446 
statement -> IF .LPAREN expression RPAREN blockStatement optionalElseStatement 
transitions ->  {"LPAREN":531}

item set 447 
statement -> FOR .LPAREN forControl RPAREN blockStatement 
transitions ->  {"LPAREN":532}

item set 448 
statement -> WHILE .LPAREN expression RPAREN blockStatement 
transitions ->  {"LPAREN":533}

item set 449 
statement -> DO .blockStatement WHILE LPAREN expression RPAREN SEMI
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":534,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 450 
statement -> TRY .block catchFinallyOrOnlyFinally
statement -> TRY .resourceSpecification block catchClauses
statement -> TRY .resourceSpecification block optionalFinallyBlock
statement -> TRY .resourceSpecification block catchClauses optionalFinallyBlock
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
resourceSpecification -> .LPAREN resources semiOpt RPAREN 
transitions ->  {"block":535,"resourceSpecification":536,"LBRACE":363,"LPAREN":537}

item set 451 
statement -> SWITCH .LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE 
transitions ->  {"LPAREN":538}

item set 452 
statement -> SYNCHRONIZED .LPAREN expression RPAREN block
modifier -> SYNCHRONIZED . 
transitions ->  {"LPAREN":539}

item set 453 
statement -> RETURN .SEMI
statement -> RETURN .expression SEMI
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"SEMI":540,"expression":541,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 454 
statement -> THROW .expression SEMI
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":542,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 455 
statement -> BREAK .optionalIdentifier SEMI
optionalIdentifier -> .
optionalIdentifier -> .Identifier 
transitions ->  {"optionalIdentifier":543,"Identifier":544}

item set 456 
statement -> CONTINUE .optionalIdentifier SEMI
optionalIdentifier -> .
optionalIdentifier -> .Identifier 
transitions ->  {"optionalIdentifier":545,"Identifier":544}

item set 457 
statement -> Identifier .COLON blockStatement
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"COLON":546,"typeParameters":70,"TEMPLATE":71}

item set 458 
statement -> expression .SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"SEMI":547,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 459 
statement -> typeDeclarationWithPrefixes . 
transitions ->  {}

item set 460 
statement -> variableDeclaratorsWithPrefixes . 
transitions ->  {}

item set 461 
expression -> qualifiedName .
expression -> qualifiedName .DOT CLASS
expression -> qualifiedName .DOT SUPER
expression -> qualifiedName .DOT SUPER DOT expression
expression -> qualifiedName .DOT newCreator
expression -> qualifiedName .arrayDimensionBrackl DOT CLASS
expression -> qualifiedName .DOT THIS
expression -> qualifiedName .DOT explicitGenericInvocation
expression -> qualifiedName .LBRACK expression RBRACK
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
type -> qualifiedName .arrayDimensionBracks
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":201,"arrayDimensionBrackl":548,"LBRACK":203,"arrayDimensionBracks":241,"arrayDimensionBrack":204}

item set 462 
expression -> primitiveType .DOT CLASS
expression -> primitiveType .arrayDimensionBrackl DOT CLASS
type -> primitiveType .arrayDimensionBracks
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":205,"arrayDimensionBrackl":549,"arrayDimensionBracks":243,"arrayDimensionBrack":204,"LBRACK":207}

item set 463 
typeDeclarationWithPrefixes -> annotationl .modifierL typeDeclaration
typeDeclarationWithPrefixes -> annotationl .typeDeclaration
variableDeclaratorsWithPrefixes -> annotationl .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":550,"typeDeclaration":46,"localVariableDeclaration":551,"annotation":63,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 464 
typeDeclarationWithPrefixes -> modifierL .annotationl typeDeclaration
typeDeclarationWithPrefixes -> modifierL .typeDeclaration
variableDeclaratorsWithPrefixes -> modifierL .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> modifierL .localVariableDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationl":552,"typeDeclaration":53,"localVariableDeclaration":553,"modifier":54,"annotation":10,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 465 
variableDeclaratorsWithPrefixes -> localVariableDeclaration . 
transitions ->  {}

item set 466 
localVariableDeclaration -> type .variableDeclarators
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclarators":554,"variableDeclarator":342,"variableDeclaratorId":343,"Identifier":499}

item set 467 
interfaceBodyDeclaration -> annotationl modifierL interfaceMemberDeclaration . 
transitions ->  {}

item set 468 
interfaceBodyDeclaration -> modifierL annotationl interfaceMemberDeclaration . 
transitions ->  {}

item set 469 
interfaceMemberDeclaration -> type constDelarators SEMI . 
transitions ->  {}

item set 470 
constDelarators -> constDelarators COMMA .constantDeclarator
constantDeclarator -> .Identifier ASSIGN variableInitializer
constantDeclarator -> .Identifier arrayDimensionBrackl ASSIGN variableInitializer 
transitions ->  {"constantDeclarator":555,"Identifier":556}

item set 471 
interfaceMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks SEMI
interfaceMemberDeclaration -> type Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":557,"SEMI":558,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 472 
constantDeclarator -> Identifier ASSIGN .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"variableInitializer":559,"arrayInitializer":502,"expression":503,"LBRACE":504,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 473 
constantDeclarator -> Identifier arrayDimensionBrackl .ASSIGN variableInitializer
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"ASSIGN":560,"arrayDimensionBrack":301,"LBRACK":207}

item set 474 
interfaceMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks SEMI
interfaceMemberDeclaration -> VOID Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":561,"SEMI":562,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 475 
interfaceMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier .formalParameters SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":563,"LPAREN":438}

item set 476 
interfaceMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters type Identifier .formalParameters SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":564,"LPAREN":438}

item set 477 
enumBodyDeclaration -> enumConstants COMMA SEMI .
enumBodyDeclaration -> enumConstants COMMA SEMI .classBodyDeclarationl
classBodyDeclarationl -> .classBodyDeclaration
classBodyDeclarationl -> .classBodyDeclarationl classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclarationl":565,"classBodyDeclaration":347,"SEMI":348,"annotationl":349,"modifierL":350,"classMemberDeclaration":351,"classStaticBlock":352,"annotation":10,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":361,"block":362,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":363,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 478 
enumConstants -> enumConstants COMMA annotations .Identifier enumConstantArguments enumConstantClassBody 
transitions ->  {"Identifier":566}

item set 479 
enumBodyDeclaration -> enumConstants SEMI classBodyDeclarationl .
classBodyDeclarationl -> classBodyDeclarationl .classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclaration":426,"SEMI":348,"annotationl":349,"modifierL":350,"classMemberDeclaration":351,"classStaticBlock":352,"annotation":10,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":361,"block":362,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":363,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 480 
enumConstants -> annotations Identifier enumConstantArguments .enumConstantClassBody
enumConstantClassBody -> .
enumConstantClassBody -> .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"enumConstantClassBody":567,"classBody":568,"LBRACE":239}

item set 481 
enumConstantArguments -> arguments . 
transitions ->  {}

item set 482 
expression -> expression DOT SUPER DOT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 483 
expression -> expression DOT SUPER LPAREN RPAREN .
arguments -> LPAREN RPAREN . 
transitions ->  {}

item set 484 
expression -> expression DOT NEW optionalNonWildcardTypeArguments innerCreator . 
transitions ->  {}

item set 485 
innerCreator -> Identifier .optionalNonWildcardTypeArgumentsOrDiamond classCreatorRest
optionalNonWildcardTypeArgumentsOrDiamond -> .
optionalNonWildcardTypeArgumentsOrDiamond -> .nonWildcardTypeArgumentsOrDiamond
nonWildcardTypeArgumentsOrDiamond -> .LT GT
nonWildcardTypeArgumentsOrDiamond -> .nonWildcardTypeArguments
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalNonWildcardTypeArgumentsOrDiamond":569,"nonWildcardTypeArgumentsOrDiamond":570,"LT":571,"nonWildcardTypeArguments":572,"TEMPLATE":131}

item set 486 
expression -> expression DOT typeParameters Identifier arguments . 
transitions ->  {}

item set 487 
expressionList -> expressionList COMMA expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 488 
expression -> expression GT GT GT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 489 
expression -> expression QUESTION expression COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 490 
expression -> qualifiedName DOT SUPER DOT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 491 
superSuffix -> DOT Identifier arguments . 
transitions ->  {}

item set 492 
parExpression -> LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN . 
transitions ->  {}

item set 493 
arrayCreatorRest -> LBRACK RBRACK arrayDimensionBracks .arrayInitializer
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE 
transitions ->  {"arrayInitializer":573,"LBRACE":504}

item set 494 
bracketedExpressions -> LBRACK expression RBRACK . 
transitions ->  {}

item set 495 
bracketedExpressions -> bracketedExpressions LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":574,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 496 
classCreatorRest -> LPAREN RPAREN classBody . 
transitions ->  {}

item set 497 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList DOT Identifier .typeArgumentsOrDiamond
typeArgumentsOrDiamond -> .LT GT
typeArgumentsOrDiamond -> .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeArgumentsOrDiamond":575,"LT":329,"typeParameters":330,"TEMPLATE":71}

item set 498 
variableDeclarators -> variableDeclarators COMMA variableDeclarator . 
transitions ->  {}

item set 499 
variableDeclaratorId -> Identifier .arrayDimensionBracks
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":421,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 500 
annotationMethodRest -> Identifier LPAREN RPAREN .defaultValue
annotationMethodRest -> Identifier LPAREN RPAREN .
defaultValue -> .DEFAULT elementValue 
transitions ->  {"defaultValue":576,"DEFAULT":577}

item set 501 
variableDeclarator -> variableDeclaratorId ASSIGN variableInitializer . 
transitions ->  {}

item set 502 
variableInitializer -> arrayInitializer . 
transitions ->  {}

item set 503 
variableInitializer -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 504 
arrayInitializer -> LBRACE .RBRACE
arrayInitializer -> LBRACE .variableInitializerL SEMI RBRACE
arrayInitializer -> LBRACE .variableInitializerL RBRACE
arrayInitializer -> LBRACE .variableInitializerL COMMA RBRACE
variableInitializerL -> .variableInitializer
variableInitializerL -> .variableInitializerL COMMA variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RBRACE":578,"variableInitializerL":579,"variableInitializer":580,"arrayInitializer":502,"expression":503,"LBRACE":504,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 505 
annotationTypeElementRest -> typeParameters type annotationMethodRest SEMI . 
transitions ->  {}

item set 506 
classBodyDeclaration -> annotationl modifierL classMemberDeclaration . 
transitions ->  {}

item set 507 
classBodyDeclaration -> modifierL annotationl classMemberDeclaration . 
transitions ->  {}

item set 508 
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks throwsList block
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks block
classMemberDeclaration -> VOID Identifier formalParameters .block
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks SEMI
classMemberDeclaration -> VOID Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":581,"block":582,"SEMI":583,"arrayDimensionBrackl":242,"LBRACE":363,"arrayDimensionBrack":204,"LBRACK":207}

item set 509 
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks throwsList block
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks block
classMemberDeclaration -> type Identifier formalParameters .block
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks SEMI
classMemberDeclaration -> type Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":584,"block":585,"SEMI":586,"arrayDimensionBrackl":242,"LBRACE":363,"arrayDimensionBrack":204,"LBRACK":207}

item set 510 
classMemberDeclaration -> type variableDeclarators SEMI . 
transitions ->  {}

item set 511 
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks block
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters block
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":587,"LPAREN":438}

item set 512 
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks block
classMemberDeclaration -> typeParameters type Identifier .formalParameters block
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters type Identifier .formalParameters SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":588,"LPAREN":438}

item set 513 
classMemberDeclaration -> typeParameters Identifier formalParameters .throwsList block
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":589,"THROWS":515}

item set 514 
classMemberDeclaration -> Identifier formalParameters throwsList .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":590,"LBRACE":363}

item set 515 
throwsList -> THROWS .qualifiedNameList
qualifiedNameList -> .qualifiedName
qualifiedNameList -> .qualifiedNameList COMMA qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedNameList":591,"qualifiedName":592,"Identifier":49}

item set 516 
formalParameters -> LPAREN RPAREN . 
transitions ->  {}

item set 517 
formalParameters -> LPAREN formalParameterList .RPAREN 
transitions ->  {"RPAREN":593}

item set 518 
formalParameterList -> usualParameterList .
formalParameterList -> usualParameterList .COMMA lastFormalParameter
usualParameterList -> usualParameterList .COMMA usualParameter 
transitions ->  {"COMMA":594}

item set 519 
formalParameterList -> lastFormalParameter . 
transitions ->  {}

item set 520 
usualParameterList -> usualParameter . 
transitions ->  {}

item set 521 
lastFormalParameter -> variableModifiers .type ELLIPSIS variableDeclaratorId
usualParameter -> variableModifiers .type variableDeclaratorId
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":595,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 522 
lastFormalParameter -> type .ELLIPSIS variableDeclaratorId
usualParameter -> type .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"ELLIPSIS":596,"variableDeclaratorId":597,"Identifier":499}

item set 523 
variableModifiers -> FINAL .annotationl
variableModifiers -> FINAL .
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"annotationl":598,"annotation":10,"AT":67}

item set 524 
variableModifiers -> annotationl .
variableModifiers -> annotationl .FINAL
annotationl -> annotationl .annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"FINAL":599,"annotation":63,"AT":67}

item set 525 
block -> LBRACE blockStatementList RBRACE . 
transitions ->  {}

item set 526 
blockStatementList -> blockStatementList blockStatement . 
transitions ->  {}

item set 527 
blockStatement -> LBRACE RBRACE . 
transitions ->  {}

item set 528 
blockStatement -> LBRACE blockStatementList .RBRACE
blockStatementList -> blockStatementList .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":600,"blockStatement":526,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 529 
statement -> ASSERT assertExpression .SEMI 
transitions ->  {"SEMI":601}

item set 530 
assertExpression -> expression .
assertExpression -> expression .COLON expression
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"COLON":602,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 531 
statement -> IF LPAREN .expression RPAREN blockStatement optionalElseStatement
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":603,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 532 
statement -> FOR LPAREN .forControl RPAREN blockStatement
forControl -> .enhancedForControl
forControl -> .forInit SEMI optionalExpression SEMI optionalForUpdate
forControl -> .SEMI optionalExpression SEMI optionalForUpdate
enhancedForControl -> .modifierL type variableDeclaratorId COLON expression
enhancedForControl -> .type variableDeclaratorId COLON expression
forInit -> .variableDeclaratorsWithPrefixes
forInit -> .expressionList
modifierL -> .modifier
modifierL -> .modifierL modifier
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
expressionList -> .expression
expressionList -> .expressionList COMMA expression
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotationl -> .annotation
annotationl -> .annotationl annotation
localVariableDeclaration -> .type variableDeclarators
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"forControl":604,"enhancedForControl":605,"forInit":606,"SEMI":607,"modifierL":608,"type":609,"variableDeclaratorsWithPrefixes":610,"expressionList":611,"modifier":15,"qualifiedName":461,"primitiveType":462,"annotationl":612,"localVariableDeclaration":465,"expression":277,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"annotation":10,"parExpression":98,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"AT":67,"LPAREN":115,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 533 
statement -> WHILE LPAREN .expression RPAREN blockStatement
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":613,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 534 
statement -> DO blockStatement .WHILE LPAREN expression RPAREN SEMI 
transitions ->  {"WHILE":614}

item set 535 
statement -> TRY block .catchFinallyOrOnlyFinally
catchFinallyOrOnlyFinally -> .catchClauses optionalFinallyBlock
catchFinallyOrOnlyFinally -> .finallyBlock
catchClauses -> .catchClause
catchClauses -> .catchClauses catchClause
finallyBlock -> .FINALLY block
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block 
transitions ->  {"catchFinallyOrOnlyFinally":615,"catchClauses":616,"finallyBlock":617,"catchClause":618,"FINALLY":619,"CATCH":620}

item set 536 
statement -> TRY resourceSpecification .block catchClauses
statement -> TRY resourceSpecification .block optionalFinallyBlock
statement -> TRY resourceSpecification .block catchClauses optionalFinallyBlock
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":621,"LBRACE":363}

item set 537 
resourceSpecification -> LPAREN .resources semiOpt RPAREN
resources -> .resource
resources -> .resources SEMI resource
resource -> .variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
resource -> .classOrInterfaceType variableDeclaratorId ASSIGN expression
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
classOrInterfaceType -> .qualifiedName
classOrInterfaceType -> .qualifiedName typeParameters
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"resources":622,"resource":623,"variableModifiers":624,"classOrInterfaceType":625,"FINAL":523,"annotationl":524,"qualifiedName":626,"annotation":10,"Identifier":49,"AT":67}

item set 538 
statement -> SWITCH LPAREN .expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":627,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 539 
statement -> SYNCHRONIZED LPAREN .expression RPAREN block
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":628,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 540 
statement -> RETURN SEMI . 
transitions ->  {}

item set 541 
statement -> RETURN expression .SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"SEMI":629,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 542 
statement -> THROW expression .SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"SEMI":630,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 543 
statement -> BREAK optionalIdentifier .SEMI 
transitions ->  {"SEMI":631}

item set 544 
optionalIdentifier -> Identifier . 
transitions ->  {}

item set 545 
statement -> CONTINUE optionalIdentifier .SEMI 
transitions ->  {"SEMI":632}

item set 546 
statement -> Identifier COLON .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":633,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 547 
statement -> expression SEMI . 
transitions ->  {}

item set 548 
expression -> qualifiedName arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBracks -> arrayDimensionBrackl .
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":300,"arrayDimensionBrack":301,"LBRACK":207}

item set 549 
expression -> primitiveType arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBracks -> arrayDimensionBrackl .
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":305,"arrayDimensionBrack":301,"LBRACK":207}

item set 550 
typeDeclarationWithPrefixes -> annotationl modifierL .typeDeclaration
variableDeclaratorsWithPrefixes -> annotationl modifierL .localVariableDeclaration
modifierL -> modifierL .modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeDeclaration":65,"localVariableDeclaration":634,"modifier":54,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 551 
variableDeclaratorsWithPrefixes -> annotationl localVariableDeclaration . 
transitions ->  {}

item set 552 
typeDeclarationWithPrefixes -> modifierL annotationl .typeDeclaration
variableDeclaratorsWithPrefixes -> modifierL annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeDeclaration":75,"localVariableDeclaration":635,"annotation":63,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 553 
variableDeclaratorsWithPrefixes -> modifierL localVariableDeclaration . 
transitions ->  {}

item set 554 
localVariableDeclaration -> type variableDeclarators .
variableDeclarators -> variableDeclarators .COMMA variableDeclarator 
transitions ->  {"COMMA":419}

item set 555 
constDelarators -> constDelarators COMMA constantDeclarator . 
transitions ->  {}

item set 556 
constantDeclarator -> Identifier .ASSIGN variableInitializer
constantDeclarator -> Identifier .arrayDimensionBrackl ASSIGN variableInitializer
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"ASSIGN":472,"arrayDimensionBrackl":473,"arrayDimensionBrack":204,"LBRACK":207}

item set 557 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .throwsList SEMI
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":636,"SEMI":637,"THROWS":515}

item set 558 
interfaceMemberDeclaration -> type Identifier formalParameters SEMI . 
transitions ->  {}

item set 559 
constantDeclarator -> Identifier ASSIGN variableInitializer . 
transitions ->  {}

item set 560 
constantDeclarator -> Identifier arrayDimensionBrackl ASSIGN .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"variableInitializer":638,"arrayInitializer":502,"expression":503,"LBRACE":504,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 561 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .throwsList SEMI
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":639,"SEMI":640,"THROWS":515}

item set 562 
interfaceMemberDeclaration -> VOID Identifier formalParameters SEMI . 
transitions ->  {}

item set 563 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":641,"SEMI":642,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 564 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks throwsList SEMI
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks SEMI
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":643,"SEMI":644,"arrayDimensionBrackl":242,"arrayDimensionBrack":204,"LBRACK":207}

item set 565 
enumBodyDeclaration -> enumConstants COMMA SEMI classBodyDeclarationl .
classBodyDeclarationl -> classBodyDeclarationl .classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .VOID Identifier formalParameters block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .type Identifier formalParameters block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .VOID Identifier formalParameters SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .type Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks block
classMemberDeclaration -> .typeParameters type Identifier formalParameters block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters SEMI
classMemberDeclaration -> .type variableDeclarators SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclaration":426,"SEMI":348,"annotationl":349,"modifierL":350,"classMemberDeclaration":351,"classStaticBlock":352,"annotation":10,"modifier":15,"VOID":353,"type":354,"typeParameters":355,"Identifier":356,"classDeclaration":357,"interfaceDeclaration":358,"enumDeclaration":359,"annotationTypeDeclaration":360,"STATIC":361,"block":362,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":363,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 566 
enumConstants -> enumConstants COMMA annotations Identifier .enumConstantArguments enumConstantClassBody
enumConstantArguments -> .
enumConstantArguments -> .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"enumConstantArguments":645,"arguments":481,"LPAREN":308}

item set 567 
enumConstants -> annotations Identifier enumConstantArguments enumConstantClassBody . 
transitions ->  {}

item set 568 
enumConstantClassBody -> classBody . 
transitions ->  {}

item set 569 
innerCreator -> Identifier optionalNonWildcardTypeArgumentsOrDiamond .classCreatorRest
classCreatorRest -> .arguments
classCreatorRest -> .LPAREN RPAREN
classCreatorRest -> .LPAREN RPAREN classBody
classCreatorRest -> .arguments classBody
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"classCreatorRest":646,"arguments":324,"LPAREN":325}

item set 570 
optionalNonWildcardTypeArgumentsOrDiamond -> nonWildcardTypeArgumentsOrDiamond . 
transitions ->  {}

item set 571 
nonWildcardTypeArgumentsOrDiamond -> LT .GT 
transitions ->  {"GT":647}

item set 572 
nonWildcardTypeArgumentsOrDiamond -> nonWildcardTypeArguments . 
transitions ->  {}

item set 573 
arrayCreatorRest -> LBRACK RBRACK arrayDimensionBracks arrayInitializer . 
transitions ->  {}

item set 574 
bracketedExpressions -> bracketedExpressions LBRACK expression RBRACK . 
transitions ->  {}

item set 575 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList DOT Identifier typeArgumentsOrDiamond . 
transitions ->  {}

item set 576 
annotationMethodRest -> Identifier LPAREN RPAREN defaultValue . 
transitions ->  {}

item set 577 
defaultValue -> DEFAULT .elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValue":648,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 578 
arrayInitializer -> LBRACE RBRACE . 
transitions ->  {}

item set 579 
arrayInitializer -> LBRACE variableInitializerL .SEMI RBRACE
arrayInitializer -> LBRACE variableInitializerL .RBRACE
arrayInitializer -> LBRACE variableInitializerL .COMMA RBRACE
variableInitializerL -> variableInitializerL .COMMA variableInitializer 
transitions ->  {"SEMI":649,"RBRACE":650,"COMMA":651}

item set 580 
variableInitializerL -> variableInitializer . 
transitions ->  {}

item set 581 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .throwsList block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .throwsList SEMI
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"throwsList":652,"block":653,"SEMI":654,"THROWS":515,"LBRACE":363}

item set 582 
classMemberDeclaration -> VOID Identifier formalParameters block . 
transitions ->  {}

item set 583 
classMemberDeclaration -> VOID Identifier formalParameters SEMI . 
transitions ->  {}

item set 584 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .throwsList block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .throwsList SEMI
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"throwsList":655,"block":656,"SEMI":657,"THROWS":515,"LBRACE":363}

item set 585 
classMemberDeclaration -> type Identifier formalParameters block . 
transitions ->  {}

item set 586 
classMemberDeclaration -> type Identifier formalParameters SEMI . 
transitions ->  {}

item set 587 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":658,"block":659,"SEMI":660,"arrayDimensionBrackl":242,"LBRACE":363,"arrayDimensionBrack":204,"LBRACK":207}

item set 588 
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks throwsList block
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks block
classMemberDeclaration -> typeParameters type Identifier formalParameters .block
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks throwsList SEMI
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks SEMI
classMemberDeclaration -> typeParameters type Identifier formalParameters .SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":661,"block":662,"SEMI":663,"arrayDimensionBrackl":242,"LBRACE":363,"arrayDimensionBrack":204,"LBRACK":207}

item set 589 
classMemberDeclaration -> typeParameters Identifier formalParameters throwsList .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":664,"LBRACE":363}

item set 590 
classMemberDeclaration -> Identifier formalParameters throwsList block . 
transitions ->  {}

item set 591 
throwsList -> THROWS qualifiedNameList .
qualifiedNameList -> qualifiedNameList .COMMA qualifiedName 
transitions ->  {"COMMA":665}

item set 592 
qualifiedNameList -> qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 593 
formalParameters -> LPAREN formalParameterList RPAREN . 
transitions ->  {}

item set 594 
formalParameterList -> usualParameterList COMMA .lastFormalParameter
usualParameterList -> usualParameterList COMMA .usualParameter
lastFormalParameter -> .variableModifiers type ELLIPSIS variableDeclaratorId
lastFormalParameter -> .type ELLIPSIS variableDeclaratorId
usualParameter -> .variableModifiers type variableDeclaratorId
usualParameter -> .type variableDeclaratorId
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"lastFormalParameter":666,"usualParameter":667,"variableModifiers":521,"type":522,"FINAL":523,"annotationl":524,"qualifiedName":138,"primitiveType":139,"annotation":10,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"AT":67}

item set 595 
lastFormalParameter -> variableModifiers type .ELLIPSIS variableDeclaratorId
usualParameter -> variableModifiers type .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"ELLIPSIS":668,"variableDeclaratorId":669,"Identifier":499}

item set 596 
lastFormalParameter -> type ELLIPSIS .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":670,"Identifier":499}

item set 597 
usualParameter -> type variableDeclaratorId . 
transitions ->  {}

item set 598 
variableModifiers -> FINAL annotationl .
annotationl -> annotationl .annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"annotation":63,"AT":67}

item set 599 
variableModifiers -> annotationl FINAL . 
transitions ->  {}

item set 600 
blockStatement -> LBRACE blockStatementList RBRACE . 
transitions ->  {}

item set 601 
statement -> ASSERT assertExpression SEMI . 
transitions ->  {}

item set 602 
assertExpression -> expression COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":671,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 603 
statement -> IF LPAREN expression .RPAREN blockStatement optionalElseStatement
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":672,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 604 
statement -> FOR LPAREN forControl .RPAREN blockStatement 
transitions ->  {"RPAREN":673}

item set 605 
forControl -> enhancedForControl . 
transitions ->  {}

item set 606 
forControl -> forInit .SEMI optionalExpression SEMI optionalForUpdate 
transitions ->  {"SEMI":674}

item set 607 
forControl -> SEMI .optionalExpression SEMI optionalForUpdate
optionalExpression -> .
optionalExpression -> .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalExpression":675,"expression":676,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 608 
enhancedForControl -> modifierL .type variableDeclaratorId COLON expression
modifierL -> modifierL .modifier
variableDeclaratorsWithPrefixes -> modifierL .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> modifierL .localVariableDeclaration
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotationl -> .annotation
annotationl -> .annotationl annotation
localVariableDeclaration -> .type variableDeclarators
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"type":677,"modifier":54,"annotationl":678,"localVariableDeclaration":553,"qualifiedName":138,"primitiveType":139,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"annotation":10,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"AT":67}

item set 609 
enhancedForControl -> type .variableDeclaratorId COLON expression
localVariableDeclaration -> type .variableDeclarators
variableDeclaratorId -> .Identifier arrayDimensionBracks
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer 
transitions ->  {"variableDeclaratorId":679,"variableDeclarators":554,"Identifier":499,"variableDeclarator":342}

item set 610 
forInit -> variableDeclaratorsWithPrefixes . 
transitions ->  {}

item set 611 
forInit -> expressionList .
expressionList -> expressionList .COMMA expression 
transitions ->  {"COMMA":391}

item set 612 
variableDeclaratorsWithPrefixes -> annotationl .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":680,"localVariableDeclaration":551,"annotation":63,"modifier":15,"type":466,"AT":67,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 613 
statement -> WHILE LPAREN expression .RPAREN blockStatement
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":681,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 614 
statement -> DO blockStatement WHILE .LPAREN expression RPAREN SEMI 
transitions ->  {"LPAREN":682}

item set 615 
statement -> TRY block catchFinallyOrOnlyFinally . 
transitions ->  {}

item set 616 
catchFinallyOrOnlyFinally -> catchClauses .optionalFinallyBlock
catchClauses -> catchClauses .catchClause
optionalFinallyBlock -> .
optionalFinallyBlock -> .finallyBlock
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block
finallyBlock -> .FINALLY block 
transitions ->  {"optionalFinallyBlock":683,"catchClause":684,"finallyBlock":685,"CATCH":620,"FINALLY":619}

item set 617 
catchFinallyOrOnlyFinally -> finallyBlock . 
transitions ->  {}

item set 618 
catchClauses -> catchClause . 
transitions ->  {}

item set 619 
finallyBlock -> FINALLY .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":686,"LBRACE":363}

item set 620 
catchClause -> CATCH .LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> CATCH .LPAREN catchType Identifier RPAREN block 
transitions ->  {"LPAREN":687}

item set 621 
statement -> TRY resourceSpecification block .catchClauses
statement -> TRY resourceSpecification block .optionalFinallyBlock
statement -> TRY resourceSpecification block .catchClauses optionalFinallyBlock
catchClauses -> .catchClause
catchClauses -> .catchClauses catchClause
optionalFinallyBlock -> .
optionalFinallyBlock -> .finallyBlock
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block
finallyBlock -> .FINALLY block 
transitions ->  {"catchClauses":688,"optionalFinallyBlock":689,"catchClause":618,"finallyBlock":685,"CATCH":620,"FINALLY":619}

item set 622 
resourceSpecification -> LPAREN resources .semiOpt RPAREN
resources -> resources .SEMI resource
semiOpt -> .
semiOpt -> .SEMI 
transitions ->  {"semiOpt":690,"SEMI":691}

item set 623 
resources -> resource . 
transitions ->  {}

item set 624 
resource -> variableModifiers .classOrInterfaceType variableDeclaratorId ASSIGN expression
classOrInterfaceType -> .qualifiedName
classOrInterfaceType -> .qualifiedName typeParameters
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"classOrInterfaceType":692,"qualifiedName":626,"Identifier":49}

item set 625 
resource -> classOrInterfaceType .variableDeclaratorId ASSIGN expression
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":693,"Identifier":499}

item set 626 
classOrInterfaceType -> qualifiedName .
classOrInterfaceType -> qualifiedName .typeParameters
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeParameters":694,"DOT":69,"TEMPLATE":71}

item set 627 
statement -> SWITCH LPAREN expression .RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":695,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 628 
statement -> SYNCHRONIZED LPAREN expression .RPAREN block
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":696,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 629 
statement -> RETURN expression SEMI . 
transitions ->  {}

item set 630 
statement -> THROW expression SEMI . 
transitions ->  {}

item set 631 
statement -> BREAK optionalIdentifier SEMI . 
transitions ->  {}

item set 632 
statement -> CONTINUE optionalIdentifier SEMI . 
transitions ->  {}

item set 633 
statement -> Identifier COLON blockStatement . 
transitions ->  {}

item set 634 
variableDeclaratorsWithPrefixes -> annotationl modifierL localVariableDeclaration . 
transitions ->  {}

item set 635 
variableDeclaratorsWithPrefixes -> modifierL annotationl localVariableDeclaration . 
transitions ->  {}

item set 636 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList .SEMI 
transitions ->  {"SEMI":697}

item set 637 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 638 
constantDeclarator -> Identifier arrayDimensionBrackl ASSIGN variableInitializer . 
transitions ->  {}

item set 639 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList .SEMI 
transitions ->  {"SEMI":698}

item set 640 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 641 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .throwsList SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":699,"SEMI":700,"THROWS":515}

item set 642 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters SEMI . 
transitions ->  {}

item set 643 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .throwsList SEMI
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":701,"SEMI":702,"THROWS":515}

item set 644 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters SEMI . 
transitions ->  {}

item set 645 
enumConstants -> enumConstants COMMA annotations Identifier enumConstantArguments .enumConstantClassBody
enumConstantClassBody -> .
enumConstantClassBody -> .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"enumConstantClassBody":703,"classBody":568,"LBRACE":239}

item set 646 
innerCreator -> Identifier optionalNonWildcardTypeArgumentsOrDiamond classCreatorRest . 
transitions ->  {}

item set 647 
nonWildcardTypeArgumentsOrDiamond -> LT GT . 
transitions ->  {}

item set 648 
defaultValue -> DEFAULT elementValue . 
transitions ->  {}

item set 649 
arrayInitializer -> LBRACE variableInitializerL SEMI .RBRACE 
transitions ->  {"RBRACE":704}

item set 650 
arrayInitializer -> LBRACE variableInitializerL RBRACE . 
transitions ->  {}

item set 651 
arrayInitializer -> LBRACE variableInitializerL COMMA .RBRACE
variableInitializerL -> variableInitializerL COMMA .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RBRACE":705,"variableInitializer":706,"arrayInitializer":502,"expression":503,"LBRACE":504,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 652 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList .block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":707,"SEMI":708,"LBRACE":363}

item set 653 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks block . 
transitions ->  {}

item set 654 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 655 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList .block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":709,"SEMI":710,"LBRACE":363}

item set 656 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks block . 
transitions ->  {}

item set 657 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 658 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .throwsList block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .throwsList SEMI
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"throwsList":711,"block":712,"SEMI":713,"THROWS":515,"LBRACE":363}

item set 659 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters block . 
transitions ->  {}

item set 660 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters SEMI . 
transitions ->  {}

item set 661 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .throwsList block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .throwsList SEMI
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"throwsList":714,"block":715,"SEMI":716,"THROWS":515,"LBRACE":363}

item set 662 
classMemberDeclaration -> typeParameters type Identifier formalParameters block . 
transitions ->  {}

item set 663 
classMemberDeclaration -> typeParameters type Identifier formalParameters SEMI . 
transitions ->  {}

item set 664 
classMemberDeclaration -> typeParameters Identifier formalParameters throwsList block . 
transitions ->  {}

item set 665 
qualifiedNameList -> qualifiedNameList COMMA .qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":717,"Identifier":49}

item set 666 
formalParameterList -> usualParameterList COMMA lastFormalParameter . 
transitions ->  {}

item set 667 
usualParameterList -> usualParameterList COMMA usualParameter . 
transitions ->  {}

item set 668 
lastFormalParameter -> variableModifiers type ELLIPSIS .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":718,"Identifier":499}

item set 669 
usualParameter -> variableModifiers type variableDeclaratorId . 
transitions ->  {}

item set 670 
lastFormalParameter -> type ELLIPSIS variableDeclaratorId . 
transitions ->  {}

item set 671 
assertExpression -> expression COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 672 
statement -> IF LPAREN expression RPAREN .blockStatement optionalElseStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":719,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 673 
statement -> FOR LPAREN forControl RPAREN .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":720,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 674 
forControl -> forInit SEMI .optionalExpression SEMI optionalForUpdate
optionalExpression -> .
optionalExpression -> .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalExpression":721,"expression":676,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 675 
forControl -> SEMI optionalExpression .SEMI optionalForUpdate 
transitions ->  {"SEMI":722}

item set 676 
optionalExpression -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 677 
enhancedForControl -> modifierL type .variableDeclaratorId COLON expression
localVariableDeclaration -> type .variableDeclarators
variableDeclaratorId -> .Identifier arrayDimensionBracks
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer 
transitions ->  {"variableDeclaratorId":723,"variableDeclarators":554,"Identifier":499,"variableDeclarator":342}

item set 678 
variableDeclaratorsWithPrefixes -> modifierL annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"localVariableDeclaration":635,"annotation":63,"type":466,"AT":67,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 679 
enhancedForControl -> type variableDeclaratorId .COLON expression
variableDeclarator -> variableDeclaratorId .
variableDeclarator -> variableDeclaratorId .ASSIGN variableInitializer 
transitions ->  {"COLON":724,"ASSIGN":422}

item set 680 
variableDeclaratorsWithPrefixes -> annotationl modifierL .localVariableDeclaration
modifierL -> modifierL .modifier
localVariableDeclaration -> .type variableDeclarators
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"localVariableDeclaration":634,"modifier":54,"type":466,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":138,"primitiveType":139,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 681 
statement -> WHILE LPAREN expression RPAREN .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":725,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 682 
statement -> DO blockStatement WHILE LPAREN .expression RPAREN SEMI
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":726,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 683 
catchFinallyOrOnlyFinally -> catchClauses optionalFinallyBlock . 
transitions ->  {}

item set 684 
catchClauses -> catchClauses catchClause . 
transitions ->  {}

item set 685 
optionalFinallyBlock -> finallyBlock . 
transitions ->  {}

item set 686 
finallyBlock -> FINALLY block . 
transitions ->  {}

item set 687 
catchClause -> CATCH LPAREN .variableModifiers catchType Identifier RPAREN block
catchClause -> CATCH LPAREN .catchType Identifier RPAREN block
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
catchType -> .qualifiedName
catchType -> .catchType BITOR qualifiedName
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"variableModifiers":727,"catchType":728,"FINAL":523,"annotationl":524,"qualifiedName":729,"annotation":10,"Identifier":49,"AT":67}

item set 688 
statement -> TRY resourceSpecification block catchClauses .
statement -> TRY resourceSpecification block catchClauses .optionalFinallyBlock
catchClauses -> catchClauses .catchClause
optionalFinallyBlock -> .
optionalFinallyBlock -> .finallyBlock
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block
finallyBlock -> .FINALLY block 
transitions ->  {"optionalFinallyBlock":730,"catchClause":684,"finallyBlock":685,"CATCH":620,"FINALLY":619}

item set 689 
statement -> TRY resourceSpecification block optionalFinallyBlock . 
transitions ->  {}

item set 690 
resourceSpecification -> LPAREN resources semiOpt .RPAREN 
transitions ->  {"RPAREN":731}

item set 691 
resources -> resources SEMI .resource
semiOpt -> SEMI .
resource -> .variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
resource -> .classOrInterfaceType variableDeclaratorId ASSIGN expression
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
classOrInterfaceType -> .qualifiedName
classOrInterfaceType -> .qualifiedName typeParameters
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"resource":732,"variableModifiers":624,"classOrInterfaceType":625,"FINAL":523,"annotationl":524,"qualifiedName":626,"annotation":10,"Identifier":49,"AT":67}

item set 692 
resource -> variableModifiers classOrInterfaceType .variableDeclaratorId ASSIGN expression
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":733,"Identifier":499}

item set 693 
resource -> classOrInterfaceType variableDeclaratorId .ASSIGN expression 
transitions ->  {"ASSIGN":734}

item set 694 
classOrInterfaceType -> qualifiedName typeParameters . 
transitions ->  {}

item set 695 
statement -> SWITCH LPAREN expression RPAREN .LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE 
transitions ->  {"LBRACE":735}

item set 696 
statement -> SYNCHRONIZED LPAREN expression RPAREN .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":736,"LBRACE":363}

item set 697 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 698 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 699 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList .SEMI 
transitions ->  {"SEMI":737}

item set 700 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 701 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList .SEMI 
transitions ->  {"SEMI":738}

item set 702 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 703 
enumConstants -> enumConstants COMMA annotations Identifier enumConstantArguments enumConstantClassBody . 
transitions ->  {}

item set 704 
arrayInitializer -> LBRACE variableInitializerL SEMI RBRACE . 
transitions ->  {}

item set 705 
arrayInitializer -> LBRACE variableInitializerL COMMA RBRACE . 
transitions ->  {}

item set 706 
variableInitializerL -> variableInitializerL COMMA variableInitializer . 
transitions ->  {}

item set 707 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList block . 
transitions ->  {}

item set 708 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 709 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList block . 
transitions ->  {}

item set 710 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 711 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList .block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":739,"SEMI":740,"LBRACE":363}

item set 712 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks block . 
transitions ->  {}

item set 713 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 714 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList .block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":741,"SEMI":742,"LBRACE":363}

item set 715 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks block . 
transitions ->  {}

item set 716 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks SEMI . 
transitions ->  {}

item set 717 
qualifiedNameList -> qualifiedNameList COMMA qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 718 
lastFormalParameter -> variableModifiers type ELLIPSIS variableDeclaratorId . 
transitions ->  {}

item set 719 
statement -> IF LPAREN expression RPAREN blockStatement .optionalElseStatement
optionalElseStatement -> .
optionalElseStatement -> .ELSE blockStatement 
transitions ->  {"optionalElseStatement":743,"ELSE":744}

item set 720 
statement -> FOR LPAREN forControl RPAREN blockStatement . 
transitions ->  {}

item set 721 
forControl -> forInit SEMI optionalExpression .SEMI optionalForUpdate 
transitions ->  {"SEMI":745}

item set 722 
forControl -> SEMI optionalExpression SEMI .optionalForUpdate
optionalForUpdate -> .
optionalForUpdate -> .forUpdate
forUpdate -> .expressionList
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalForUpdate":746,"forUpdate":747,"expressionList":748,"expression":277,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 723 
enhancedForControl -> modifierL type variableDeclaratorId .COLON expression
variableDeclarator -> variableDeclaratorId .
variableDeclarator -> variableDeclaratorId .ASSIGN variableInitializer 
transitions ->  {"COLON":749,"ASSIGN":422}

item set 724 
enhancedForControl -> type variableDeclaratorId COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":750,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 725 
statement -> WHILE LPAREN expression RPAREN blockStatement . 
transitions ->  {}

item set 726 
statement -> DO blockStatement WHILE LPAREN expression .RPAREN SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":751,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 727 
catchClause -> CATCH LPAREN variableModifiers .catchType Identifier RPAREN block
catchType -> .qualifiedName
catchType -> .catchType BITOR qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"catchType":752,"qualifiedName":729,"Identifier":49}

item set 728 
catchClause -> CATCH LPAREN catchType .Identifier RPAREN block
catchType -> catchType .BITOR qualifiedName 
transitions ->  {"Identifier":753,"BITOR":754}

item set 729 
catchType -> qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 730 
statement -> TRY resourceSpecification block catchClauses optionalFinallyBlock . 
transitions ->  {}

item set 731 
resourceSpecification -> LPAREN resources semiOpt RPAREN . 
transitions ->  {}

item set 732 
resources -> resources SEMI resource . 
transitions ->  {}

item set 733 
resource -> variableModifiers classOrInterfaceType variableDeclaratorId .ASSIGN expression 
transitions ->  {"ASSIGN":755}

item set 734 
resource -> classOrInterfaceType variableDeclaratorId ASSIGN .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":756,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 735 
statement -> SWITCH LPAREN expression RPAREN LBRACE .switchBlockStatementGroups emptySwitchLabels RBRACE
switchBlockStatementGroups -> .
switchBlockStatementGroups -> .switchBlockStatementGroupL
switchBlockStatementGroupL -> .switchBlockStatementGroup
switchBlockStatementGroupL -> .switchBlockStatementGroupL switchBlockStatementGroup
switchBlockStatementGroup -> .switchLabelL blockStatementList
switchBlockStatementGroup -> .switchLabelL
switchLabelL -> .switchLabel
switchLabelL -> .switchLabelL switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"switchBlockStatementGroups":757,"switchBlockStatementGroupL":758,"switchBlockStatementGroup":759,"switchLabelL":760,"switchLabel":761,"CASE":762,"DEFAULT":763}

item set 736 
statement -> SYNCHRONIZED LPAREN expression RPAREN block . 
transitions ->  {}

item set 737 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 738 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 739 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList block . 
transitions ->  {}

item set 740 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 741 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList block . 
transitions ->  {}

item set 742 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList SEMI . 
transitions ->  {}

item set 743 
statement -> IF LPAREN expression RPAREN blockStatement optionalElseStatement . 
transitions ->  {}

item set 744 
optionalElseStatement -> ELSE .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":764,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 745 
forControl -> forInit SEMI optionalExpression SEMI .optionalForUpdate
optionalForUpdate -> .
optionalForUpdate -> .forUpdate
forUpdate -> .expressionList
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalForUpdate":765,"forUpdate":747,"expressionList":748,"expression":277,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 746 
forControl -> SEMI optionalExpression SEMI optionalForUpdate . 
transitions ->  {}

item set 747 
optionalForUpdate -> forUpdate . 
transitions ->  {}

item set 748 
forUpdate -> expressionList .
expressionList -> expressionList .COMMA expression 
transitions ->  {"COMMA":391}

item set 749 
enhancedForControl -> modifierL type variableDeclaratorId COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":766,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 750 
enhancedForControl -> type variableDeclaratorId COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 751 
statement -> DO blockStatement WHILE LPAREN expression RPAREN .SEMI 
transitions ->  {"SEMI":767}

item set 752 
catchClause -> CATCH LPAREN variableModifiers catchType .Identifier RPAREN block
catchType -> catchType .BITOR qualifiedName 
transitions ->  {"Identifier":768,"BITOR":754}

item set 753 
catchClause -> CATCH LPAREN catchType Identifier .RPAREN block 
transitions ->  {"RPAREN":769}

item set 754 
catchType -> catchType BITOR .qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":770,"Identifier":49}

item set 755 
resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":771,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 756 
resource -> classOrInterfaceType variableDeclaratorId ASSIGN expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 757 
statement -> SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups .emptySwitchLabels RBRACE
emptySwitchLabels -> .
emptySwitchLabels -> .switchLabelL
switchLabelL -> .switchLabel
switchLabelL -> .switchLabelL switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"emptySwitchLabels":772,"switchLabelL":773,"switchLabel":761,"CASE":762,"DEFAULT":763}

item set 758 
switchBlockStatementGroups -> switchBlockStatementGroupL .
switchBlockStatementGroupL -> switchBlockStatementGroupL .switchBlockStatementGroup
switchBlockStatementGroup -> .switchLabelL blockStatementList
switchBlockStatementGroup -> .switchLabelL
switchLabelL -> .switchLabel
switchLabelL -> .switchLabelL switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"switchBlockStatementGroup":774,"switchLabelL":760,"switchLabel":761,"CASE":762,"DEFAULT":763}

item set 759 
switchBlockStatementGroupL -> switchBlockStatementGroup . 
transitions ->  {}

item set 760 
switchBlockStatementGroup -> switchLabelL .blockStatementList
switchBlockStatementGroup -> switchLabelL .
switchLabelL -> switchLabelL .switchLabel
blockStatementList -> .blockStatement
blockStatementList -> .blockStatementList blockStatement
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatementList":775,"switchLabel":776,"blockStatement":442,"CASE":762,"DEFAULT":763,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 761 
switchLabelL -> switchLabel . 
transitions ->  {}

item set 762 
switchLabel -> CASE .expression COLON
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":777,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 763 
switchLabel -> DEFAULT .COLON 
transitions ->  {"COLON":778}

item set 764 
optionalElseStatement -> ELSE blockStatement . 
transitions ->  {}

item set 765 
forControl -> forInit SEMI optionalExpression SEMI optionalForUpdate . 
transitions ->  {}

item set 766 
enhancedForControl -> modifierL type variableDeclaratorId COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 767 
statement -> DO blockStatement WHILE LPAREN expression RPAREN SEMI . 
transitions ->  {}

item set 768 
catchClause -> CATCH LPAREN variableModifiers catchType Identifier .RPAREN block 
transitions ->  {"RPAREN":779}

item set 769 
catchClause -> CATCH LPAREN catchType Identifier RPAREN .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":780,"LBRACE":363}

item set 770 
catchType -> catchType BITOR qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 771 
resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 772 
statement -> SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels .RBRACE 
transitions ->  {"RBRACE":781}

item set 773 
emptySwitchLabels -> switchLabelL .
switchLabelL -> switchLabelL .switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"switchLabel":776,"CASE":762,"DEFAULT":763}

item set 774 
switchBlockStatementGroupL -> switchBlockStatementGroupL switchBlockStatementGroup . 
transitions ->  {}

item set 775 
switchBlockStatementGroup -> switchLabelL blockStatementList .
blockStatementList -> blockStatementList .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":526,"statement":443,"LBRACE":444,"ASSERT":445,"IF":446,"FOR":447,"WHILE":448,"DO":449,"TRY":450,"SWITCH":451,"SYNCHRONIZED":452,"RETURN":453,"THROW":454,"BREAK":455,"CONTINUE":456,"Identifier":457,"expression":458,"typeDeclarationWithPrefixes":459,"variableDeclaratorsWithPrefixes":460,"parExpression":98,"qualifiedName":461,"primitiveType":462,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":463,"modifierL":464,"typeDeclaration":13,"localVariableDeclaration":465,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":466,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 776 
switchLabelL -> switchLabelL switchLabel . 
transitions ->  {}

item set 777 
switchLabel -> CASE expression .COLON
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"COLON":782,"DOT":154,"LBRACK":155,"arguments":156,"LPAREN":157,"incrementOrDecrement":158,"mulDivOrMod":159,"addOrSub":160,"LSHIFT":161,"GT":162,"lE_GE_LT_GT":163,"INSTANCEOF":164,"equals_NotEqual":165,"BITAND":166,"CARET":167,"BITOR":168,"AND":169,"OR":170,"QUESTION":171,"assignmentToken":172,"INC":173,"DEC":174,"MUL":175,"DIV":176,"MOD":177,"ADD":178,"SUB":179,"LE":180,"GE":181,"LT":182,"EQUAL":183,"NOTEQUAL":184,"ASSIGN":185,"ADD_ASSIGN":186,"SUB_ASSIGN":187,"MUL_ASSIGN":188,"DIV_ASSIGN":189,"AND_ASSIGN":190,"OR_ASSIGN":191,"XOR_ASSIGN":192,"RSHIFT_ASSIGN":193,"URSHIFT_ASSIGN":194,"LSHIFT_ASSIGN":195,"MOD_ASSIGN":196}

item set 778 
switchLabel -> DEFAULT COLON . 
transitions ->  {}

item set 779 
catchClause -> CATCH LPAREN variableModifiers catchType Identifier RPAREN .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":783,"LBRACE":363}

item set 780 
catchClause -> CATCH LPAREN catchType Identifier RPAREN block . 
transitions ->  {}

item set 781 
statement -> SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE . 
transitions ->  {}

item set 782 
switchLabel -> CASE expression COLON . 
transitions ->  {}

item set 783 
catchClause -> CATCH LPAREN variableModifiers catchType Identifier RPAREN block . 
transitions ->  {}
784 states.
Building lookahead grammar.
Computing lookaheads.
Building parse table.
Conflict at state: 2, token: EOF
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 34)
Conflict at state: 2, token: IMPORT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 11)
Conflict at state: 2, token: AT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 14)
Conflict at state: 2, token: STATIC
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 20)
Conflict at state: 2, token: FINAL
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 21)
Conflict at state: 2, token: ABSTRACT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 22)
Conflict at state: 2, token: STRICTFP
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 23)
Conflict at state: 2, token: TRANSIENT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 24)
Conflict at state: 2, token: VOLATILE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 25)
Conflict at state: 2, token: PUBLIC
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 26)
Conflict at state: 2, token: PRIVATE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 27)
Conflict at state: 2, token: PROTECTED
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 28)
Conflict at state: 2, token: NATIVE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 29)
Conflict at state: 2, token: SYNCHRONIZED
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 30)
Conflict at state: 2, token: CLASS
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 31)
Conflict at state: 2, token: INTERFACE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 32)
Conflict at state: 2, token: ENUM
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 33)
Conflict at state: 2, token: SEMI
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 38)
Conflict at state: 5, token: $end
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: EOF
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: AT
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: STATIC
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: FINAL
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: ABSTRACT
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: STRICTFP
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: TRANSIENT
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: VOLATILE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: PUBLIC
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: PRIVATE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: PROTECTED
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: NATIVE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: SYNCHRONIZED
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: CLASS
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: INTERFACE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: ENUM
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: SEMI
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 43, token: SEMI
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: ENUM
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: INTERFACE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: CLASS
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: SYNCHRONIZED
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: NATIVE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: PROTECTED
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: PRIVATE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: PUBLIC
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: VOLATILE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: TRANSIENT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: STRICTFP
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: ABSTRACT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: FINAL
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: STATIC
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: AT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: IMPORT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: EOF
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 44, token: AT
  reduce by rule: annotationl -> annotation
  reduce by rule: annotationl -> annotationl annotation
Conflict at state: 44, token: PACKAGE
  reduce by rule: annotationl -> annotation
  reduce by rule: annotationl -> annotationl annotation
Conflict at state: 49, token: TEMPLATE
  reduce by rule: qualifiedName -> Identifier
  shift token (then go to state 71)
Conflict at state: 86, token: TEMPLATE
  reduce by rule: qualifiedName -> qualifiedName DOT Identifier
  shift token (then go to state 71)
Conflict at state: 94, token: DOT
  reduce by rule: elementValue -> expression
  shift token (then go to state 154)
Conflict at state: 94, token: LBRACK
  reduce by rule: elementValue -> expression
  shift token (then go to state 155)
Conflict at state: 94, token: LPAREN
  reduce by rule: elementValue -> expression
  shift token (then go to state 157)
Conflict at state: 94, token: INC
  reduce by rule: elementValue -> expression
  shift token (then go to state 173)
Conflict at state: 94, token: DEC
  reduce by rule: elementValue -> expression
  shift token (then go to state 174)
Conflict at state: 94, token: MUL
  reduce by rule: elementValue -> expression
  shift token (then go to state 175)
Conflict at state: 94, token: DIV
  reduce by rule: elementValue -> expression
  shift token (then go to state 176)
Conflict at state: 94, token: MOD
  reduce by rule: elementValue -> expression
  shift token (then go to state 177)
Conflict at state: 94, token: ADD
  reduce by rule: elementValue -> expression
  shift token (then go to state 178)
Conflict at state: 94, token: SUB
  reduce by rule: elementValue -> expression
  shift token (then go to state 179)
Conflict at state: 94, token: LSHIFT
  reduce by rule: elementValue -> expression
  shift token (then go to state 161)
Conflict at state: 94, token: GT
  reduce by rule: elementValue -> expression
  shift token (then go to state 162)
Conflict at state: 94, token: LE
  reduce by rule: elementValue -> expression
  shift token (then go to state 180)
Conflict at state: 94, token: GE
  reduce by rule: elementValue -> expression
  shift token (then go to state 181)
Conflict at state: 94, token: LT
  reduce by rule: elementValue -> expression
  shift token (then go to state 182)
Conflict at state: 94, token: INSTANCEOF
  reduce by rule: elementValue -> expression
  shift token (then go to state 164)
Conflict at state: 94, token: EQUAL
  reduce by rule: elementValue -> expression
  shift token (then go to state 183)
Conflict at state: 94, token: NOTEQUAL
  reduce by rule: elementValue -> expression
  shift token (then go to state 184)
Conflict at state: 94, token: BITAND
  reduce by rule: elementValue -> expression
  shift token (then go to state 166)
Conflict at state: 94, token: CARET
  reduce by rule: elementValue -> expression
  shift token (then go to state 167)
Conflict at state: 94, token: BITOR
  reduce by rule: elementValue -> expression
  shift token (then go to state 168)
Conflict at state: 94, token: AND
  reduce by rule: elementValue -> expression
  shift token (then go to state 169)
Conflict at state: 94, token: OR
  reduce by rule: elementValue -> expression
  shift token (then go to state 170)
Conflict at state: 94, token: QUESTION
  reduce by rule: elementValue -> expression
  shift token (then go to state 171)
Conflict at state: 94, token: ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 185)
Conflict at state: 94, token: ADD_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 186)
Conflict at state: 94, token: SUB_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 187)
Conflict at state: 94, token: MUL_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 188)
Conflict at state: 94, token: DIV_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 189)
Conflict at state: 94, token: AND_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 190)
Conflict at state: 94, token: OR_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 191)
Conflict at state: 94, token: XOR_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 192)
Conflict at state: 94, token: RSHIFT_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 193)
Conflict at state: 94, token: URSHIFT_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 194)
Conflict at state: 94, token: LSHIFT_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 195)
Conflict at state: 94, token: MOD_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 196)
Conflict at state: 94, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 94, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 94, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 94, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 94, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 94, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 94, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 94, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 94, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 94, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 94, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 94, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 94, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 94, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 94, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 94, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 94, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 94, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 94, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 94, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 94, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 94, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 94, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 94, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 94, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 94, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 94, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 94, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 94, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 94, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 94, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 94, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 94, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 94, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 94, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 94, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 94, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 94, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 94, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 94, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 96, token: RBRACE
  reduce by rule: annotations -> 
  shift token (then go to state 197)
Conflict at state: 97, token: ASSIGN
  reduce by rule: qualifiedName -> Identifier
  shift token (then go to state 199)
Conflict at state: 98, token: LPAREN
  reduce by rule: expression -> parExpression
  shift token (then go to state 115)
Conflict at state: 98, token: INC
  reduce by rule: expression -> parExpression
  shift token (then go to state 127)
Conflict at state: 98, token: DEC
  reduce by rule: expression -> parExpression
  shift token (then go to state 128)
Conflict at state: 98, token: ADD
  reduce by rule: expression -> parExpression
  shift token (then go to state 125)
Conflict at state: 98, token: SUB
  reduce by rule: expression -> parExpression
  shift token (then go to state 126)
Conflict at state: 98, token: TEMPLATE
  reduce by rule: expression -> parExpression
  shift token (then go to state 131)
Conflict at state: 98, token: BANG
  reduce by rule: expression -> parExpression
  shift token (then go to state 130)
Conflict at state: 98, token: TILDE
  reduce by rule: expression -> parExpression
  shift token (then go to state 129)
Conflict at state: 98, token: NEW
  reduce by rule: expression -> parExpression
  shift token (then go to state 124)
Conflict at state: 98, token: DOUBLE
  reduce by rule: expression -> parExpression
  shift token (then go to state 123)
Conflict at state: 98, token: FLOAT
  reduce by rule: expression -> parExpression
  shift token (then go to state 122)
Conflict at state: 98, token: LONG
  reduce by rule: expression -> parExpression
  shift token (then go to state 121)
Conflict at state: 98, token: INT
  reduce by rule: expression -> parExpression
  shift token (then go to state 120)
Conflict at state: 98, token: SHORT
  reduce by rule: expression -> parExpression
  shift token (then go to state 119)
Conflict at state: 98, token: BYTE
  reduce by rule: expression -> parExpression
  shift token (then go to state 118)
Conflict at state: 98, token: CHAR
  reduce by rule: expression -> parExpression
  shift token (then go to state 117)
Conflict at state: 98, token: BOOLEAN
  reduce by rule: expression -> parExpression
  shift token (then go to state 116)
Conflict at state: 98, token: VOID
  reduce by rule: expression -> parExpression
  shift token (then go to state 112)
Conflict at state: 98, token: NullLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 111)
Conflict at state: 98, token: BooleanLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 110)
Conflict at state: 98, token: StringLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 109)
Conflict at state: 98, token: CharacterLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 108)
Conflict at state: 98, token: FloatingPointLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 107)
Conflict at state: 98, token: IntegerLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 106)
Conflict at state: 98, token: SUPER
  reduce by rule: expression -> parExpression
  shift token (then go to state 105)
Conflict at state: 98, token: THIS
  reduce by rule: expression -> parExpression
  shift token (then go to state 104)
Conflict at state: 98, token: Identifier
  reduce by rule: expression -> parExpression
  shift token (then go to state 49)
Conflict at state: 99, token: DOT
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 201)
Conflict at state: 99, token: LBRACK
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 203)
Conflict at state: 138, token: DOT
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 69)
Conflict at state: 138, token: LBRACK
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 207)
Conflict at state: 139, token: LBRACK
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 207)
Conflict at state: 200, token: DOT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 154)
Conflict at state: 200, token: LBRACK
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 155)
Conflict at state: 200, token: LPAREN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 157)
Conflict at state: 200, token: INC
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 173)
Conflict at state: 200, token: DEC
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 174)
Conflict at state: 200, token: MUL
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 175)
Conflict at state: 200, token: DIV
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 176)
Conflict at state: 200, token: MOD
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 177)
Conflict at state: 200, token: ADD
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 178)
Conflict at state: 200, token: SUB
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 179)
Conflict at state: 200, token: LSHIFT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 161)
Conflict at state: 200, token: GT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 162)
Conflict at state: 200, token: LE
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 180)
Conflict at state: 200, token: GE
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 181)
Conflict at state: 200, token: LT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 182)
Conflict at state: 200, token: INSTANCEOF
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 164)
Conflict at state: 200, token: EQUAL
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 183)
Conflict at state: 200, token: NOTEQUAL
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 184)
Conflict at state: 200, token: BITAND
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 166)
Conflict at state: 200, token: CARET
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 167)
Conflict at state: 200, token: BITOR
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 168)
Conflict at state: 200, token: AND
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 169)
Conflict at state: 200, token: OR
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 170)
Conflict at state: 200, token: QUESTION
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 171)
Conflict at state: 200, token: ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 185)
Conflict at state: 200, token: ADD_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 186)
Conflict at state: 200, token: SUB_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 187)
Conflict at state: 200, token: MUL_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 188)
Conflict at state: 200, token: DIV_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 189)
Conflict at state: 200, token: AND_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 190)
Conflict at state: 200, token: OR_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 191)
Conflict at state: 200, token: XOR_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 192)
Conflict at state: 200, token: RSHIFT_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 193)
Conflict at state: 200, token: URSHIFT_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 194)
Conflict at state: 200, token: LSHIFT_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 195)
Conflict at state: 200, token: MOD_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 196)
Conflict at state: 200, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 200, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 200, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 200, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 200, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 200, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 200, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 200, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 200, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 200, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 200, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 200, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 200, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 200, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 200, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 200, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 200, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 200, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 200, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 200, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 200, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 200, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 200, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 200, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 200, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 200, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 200, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 200, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 200, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 200, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 200, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 200, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 200, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 200, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 200, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 200, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 200, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 200, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 208, token: DOT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 154)
Conflict at state: 208, token: LBRACK
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 155)
Conflict at state: 208, token: LPAREN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 157)
Conflict at state: 208, token: INC
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 173)
Conflict at state: 208, token: DEC
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 174)
Conflict at state: 208, token: MUL
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 175)
Conflict at state: 208, token: DIV
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 176)
Conflict at state: 208, token: MOD
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 177)
Conflict at state: 208, token: ADD
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 178)
Conflict at state: 208, token: SUB
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 179)
Conflict at state: 208, token: LSHIFT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 161)
Conflict at state: 208, token: GT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 162)
Conflict at state: 208, token: LE
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 180)
Conflict at state: 208, token: GE
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 181)
Conflict at state: 208, token: LT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 182)
Conflict at state: 208, token: INSTANCEOF
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 164)
Conflict at state: 208, token: EQUAL
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 183)
Conflict at state: 208, token: NOTEQUAL
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 184)
Conflict at state: 208, token: BITAND
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 166)
Conflict at state: 208, token: CARET
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 167)
Conflict at state: 208, token: BITOR
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 168)
Conflict at state: 208, token: AND
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 169)
Conflict at state: 208, token: OR
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 170)
Conflict at state: 208, token: QUESTION
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 171)
Conflict at state: 208, token: ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 185)
Conflict at state: 208, token: ADD_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 186)
Conflict at state: 208, token: SUB_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 187)
Conflict at state: 208, token: MUL_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 188)
Conflict at state: 208, token: DIV_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 189)
Conflict at state: 208, token: AND_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 190)
Conflict at state: 208, token: OR_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 191)
Conflict at state: 208, token: XOR_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 192)
Conflict at state: 208, token: RSHIFT_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 193)
Conflict at state: 208, token: URSHIFT_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 194)
Conflict at state: 208, token: LSHIFT_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 195)
Conflict at state: 208, token: MOD_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 196)
Conflict at state: 208, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 208, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 208, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 208, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 208, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 208, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 208, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 208, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 208, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 208, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 208, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 208, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 208, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 208, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 208, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 208, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 208, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 208, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 208, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 208, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 208, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 208, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 208, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 208, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 208, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 208, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 208, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 208, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 208, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 208, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 208, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 208, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 208, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 208, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 208, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 208, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 208, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 208, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 209, token: DOT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 154)
Conflict at state: 209, token: LBRACK
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 155)
Conflict at state: 209, token: LPAREN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 157)
Conflict at state: 209, token: INC
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 173)
Conflict at state: 209, token: DEC
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 174)
Conflict at state: 209, token: MUL
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 175)
Conflict at state: 209, token: DIV
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 176)
Conflict at state: 209, token: MOD
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 177)
Conflict at state: 209, token: ADD
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 178)
Conflict at state: 209, token: SUB
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 179)
Conflict at state: 209, token: LSHIFT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 161)
Conflict at state: 209, token: GT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 162)
Conflict at state: 209, token: LE
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 180)
Conflict at state: 209, token: GE
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 181)
Conflict at state: 209, token: LT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 182)
Conflict at state: 209, token: INSTANCEOF
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 164)
Conflict at state: 209, token: EQUAL
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 183)
Conflict at state: 209, token: NOTEQUAL
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 184)
Conflict at state: 209, token: BITAND
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 166)
Conflict at state: 209, token: CARET
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 167)
Conflict at state: 209, token: BITOR
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 168)
Conflict at state: 209, token: AND
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 169)
Conflict at state: 209, token: OR
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 170)
Conflict at state: 209, token: QUESTION
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 171)
Conflict at state: 209, token: ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 185)
Conflict at state: 209, token: ADD_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 186)
Conflict at state: 209, token: SUB_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 187)
Conflict at state: 209, token: MUL_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 188)
Conflict at state: 209, token: DIV_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 189)
Conflict at state: 209, token: AND_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 190)
Conflict at state: 209, token: OR_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 191)
Conflict at state: 209, token: XOR_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 192)
Conflict at state: 209, token: RSHIFT_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 193)
Conflict at state: 209, token: URSHIFT_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 194)
Conflict at state: 209, token: LSHIFT_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 195)
Conflict at state: 209, token: MOD_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 196)
Conflict at state: 209, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 209, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 209, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 209, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 209, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 209, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 209, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 209, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 209, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 209, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 209, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 209, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 209, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 209, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 209, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 209, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 209, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 209, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 209, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 209, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 209, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 209, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 209, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 209, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 209, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 209, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 209, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 209, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 209, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 209, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 209, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 209, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 209, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 209, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 209, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 209, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 209, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 209, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 216, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 313)
Conflict at state: 216, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 216, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 216, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 216, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 216, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 216, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 216, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 216, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 216, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 216, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 216, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 216, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 216, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 216, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 216, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 216, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 216, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 216, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 216, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 216, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 216, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 216, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 216, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 216, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 216, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 216, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 216, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 216, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 216, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 216, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 216, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 216, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 216, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 216, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 216, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 216, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 218, token: DOT
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 201)
Conflict at state: 218, token: LBRACK
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 203)
Conflict at state: 242, token: LBRACK
  reduce by rule: arrayDimensionBracks -> arrayDimensionBrackl
  shift token (then go to state 207)
Conflict at state: 268, token: DOT
  reduce by rule: expression -> expression DOT qualifiedName
  shift token (then go to state 69)
Conflict at state: 268, token: RPAREN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DOT
  reduce by rule: expression -> expression DOT qualifiedName
  shift token (then go to state 69)
Conflict at state: 268, token: LBRACK
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LPAREN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: INC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DEC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: MUL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DIV
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: MOD
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ADD
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SUB
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LSHIFT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: GT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: GE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: INSTANCEOF
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: EQUAL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: NOTEQUAL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BITAND
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: CARET
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BITOR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: AND
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: OR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: QUESTION
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ADD_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SUB_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: MUL_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DIV_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: AND_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: OR_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: XOR_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: MOD_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: COMMA
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: RBRACE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: RBRACK
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: COLON
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SEMI
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LBRACE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ENUM
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: INTERFACE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: CLASS
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: NATIVE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: PROTECTED
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: PRIVATE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: PUBLIC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: VOLATILE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: TRANSIENT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: STRICTFP
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ABSTRACT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: FINAL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: STATIC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: AT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: TEMPLATE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BANG
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: TILDE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: NEW
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DOUBLE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: FLOAT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: LONG
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: INT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SHORT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BYTE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: CHAR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BOOLEAN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: VOID
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: NullLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BooleanLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: StringLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: CharacterLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: FloatingPointLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: IntegerLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SUPER
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: THIS
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: Identifier
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: CONTINUE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: BREAK
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: THROW
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: RETURN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SYNCHRONIZED
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: SWITCH
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: TRY
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DO
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: WHILE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: FOR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: IF
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ASSERT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: ELSE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: DEFAULT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 268, token: CASE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 269, token: DOT
  reduce by rule: expression -> expression DOT SUPER
  shift token (then go to state 383)
Conflict at state: 269, token: LPAREN
  reduce by rule: expression -> expression DOT SUPER
  shift token (then go to state 385)
Conflict at state: 272, token: Identifier
  reduce by rule: optionalNonWildcardTypeArguments -> 
  shift token (then go to state 49)
Conflict at state: 274, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 389)
Conflict at state: 274, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 274, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 274, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 274, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 274, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 274, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 274, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 274, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 274, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 274, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 274, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 274, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 274, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 274, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 274, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 274, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 274, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 274, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 274, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 274, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 274, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 274, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 274, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 274, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 274, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 274, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 274, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 274, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 274, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 274, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 274, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 274, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 274, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 274, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 274, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 274, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 275, token: LPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DOT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: RPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: RBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: COMMA
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SEMI
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: MOD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: URSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: RSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: XOR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: OR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: AND_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DIV_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: MUL_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SUB_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ADD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: QUESTION
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: OR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: AND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BITOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: CARET
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BITAND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: NOTEQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: EQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: INSTANCEOF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: GE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: GT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LSHIFT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SUB
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ADD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: MOD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DIV
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: MUL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DEC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: INC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: COLON
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: RBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: WHILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ASSERT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: IF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: FOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DO
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: TRY
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SWITCH
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SYNCHRONIZED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: RETURN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: THROW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BREAK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: CONTINUE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: Identifier
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: THIS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SUPER
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: IntegerLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: FloatingPointLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: CharacterLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: StringLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BooleanLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: NullLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: VOID
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BOOLEAN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: CHAR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BYTE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: SHORT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: INT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LONG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: FLOAT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DOUBLE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: NEW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: TILDE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: BANG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: TEMPLATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: AT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: STATIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: FINAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ABSTRACT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: STRICTFP
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: TRANSIENT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: VOLATILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: PUBLIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: PRIVATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: PROTECTED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: NATIVE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: CLASS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: INTERFACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ENUM
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: LBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: DEFAULT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: CASE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 275, token: ELSE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 277, token: DOT
  reduce by rule: expressionList -> expression
  shift token (then go to state 154)
Conflict at state: 277, token: LBRACK
  reduce by rule: expressionList -> expression
  shift token (then go to state 155)
Conflict at state: 277, token: LPAREN
  reduce by rule: expressionList -> expression
  shift token (then go to state 157)
Conflict at state: 277, token: INC
  reduce by rule: expressionList -> expression
  shift token (then go to state 173)
Conflict at state: 277, token: DEC
  reduce by rule: expressionList -> expression
  shift token (then go to state 174)
Conflict at state: 277, token: MUL
  reduce by rule: expressionList -> expression
  shift token (then go to state 175)
Conflict at state: 277, token: DIV
  reduce by rule: expressionList -> expression
  shift token (then go to state 176)
Conflict at state: 277, token: MOD
  reduce by rule: expressionList -> expression
  shift token (then go to state 177)
Conflict at state: 277, token: ADD
  reduce by rule: expressionList -> expression
  shift token (then go to state 178)
Conflict at state: 277, token: SUB
  reduce by rule: expressionList -> expression
  shift token (then go to state 179)
Conflict at state: 277, token: LSHIFT
  reduce by rule: expressionList -> expression
  shift token (then go to state 161)
Conflict at state: 277, token: GT
  reduce by rule: expressionList -> expression
  shift token (then go to state 162)
Conflict at state: 277, token: LE
  reduce by rule: expressionList -> expression
  shift token (then go to state 180)
Conflict at state: 277, token: GE
  reduce by rule: expressionList -> expression
  shift token (then go to state 181)
Conflict at state: 277, token: LT
  reduce by rule: expressionList -> expression
  shift token (then go to state 182)
Conflict at state: 277, token: INSTANCEOF
  reduce by rule: expressionList -> expression
  shift token (then go to state 164)
Conflict at state: 277, token: EQUAL
  reduce by rule: expressionList -> expression
  shift token (then go to state 183)
Conflict at state: 277, token: NOTEQUAL
  reduce by rule: expressionList -> expression
  shift token (then go to state 184)
Conflict at state: 277, token: BITAND
  reduce by rule: expressionList -> expression
  shift token (then go to state 166)
Conflict at state: 277, token: CARET
  reduce by rule: expressionList -> expression
  shift token (then go to state 167)
Conflict at state: 277, token: BITOR
  reduce by rule: expressionList -> expression
  shift token (then go to state 168)
Conflict at state: 277, token: AND
  reduce by rule: expressionList -> expression
  shift token (then go to state 169)
Conflict at state: 277, token: OR
  reduce by rule: expressionList -> expression
  shift token (then go to state 170)
Conflict at state: 277, token: QUESTION
  reduce by rule: expressionList -> expression
  shift token (then go to state 171)
Conflict at state: 277, token: ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 185)
Conflict at state: 277, token: ADD_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 186)
Conflict at state: 277, token: SUB_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 187)
Conflict at state: 277, token: MUL_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 188)
Conflict at state: 277, token: DIV_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 189)
Conflict at state: 277, token: AND_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 190)
Conflict at state: 277, token: OR_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 191)
Conflict at state: 277, token: XOR_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 192)
Conflict at state: 277, token: RSHIFT_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 193)
Conflict at state: 277, token: URSHIFT_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 194)
Conflict at state: 277, token: LSHIFT_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 195)
Conflict at state: 277, token: MOD_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 196)
Conflict at state: 277, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expression
Conflict at state: 277, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expression
Conflict at state: 277, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 277, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 277, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 277, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 277, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 277, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 277, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 277, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 277, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 277, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 277, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 277, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 277, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 277, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 277, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 277, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 277, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 277, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 277, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 277, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 277, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 277, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 277, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 277, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 277, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 277, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 277, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 277, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 277, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 277, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 277, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 277, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 277, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 277, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 277, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 277, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 277, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expression
Conflict at state: 278, token: DOT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 154)
Conflict at state: 278, token: LBRACK
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 155)
Conflict at state: 278, token: LPAREN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 157)
Conflict at state: 278, token: INC
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 173)
Conflict at state: 278, token: DEC
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 174)
Conflict at state: 278, token: MUL
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 175)
Conflict at state: 278, token: DIV
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 176)
Conflict at state: 278, token: MOD
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 177)
Conflict at state: 278, token: ADD
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 178)
Conflict at state: 278, token: SUB
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 179)
Conflict at state: 278, token: LSHIFT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 161)
Conflict at state: 278, token: GT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 162)
Conflict at state: 278, token: LE
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 180)
Conflict at state: 278, token: GE
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 181)
Conflict at state: 278, token: LT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 182)
Conflict at state: 278, token: INSTANCEOF
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 164)
Conflict at state: 278, token: EQUAL
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 183)
Conflict at state: 278, token: NOTEQUAL
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 184)
Conflict at state: 278, token: BITAND
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 166)
Conflict at state: 278, token: CARET
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 167)
Conflict at state: 278, token: BITOR
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 168)
Conflict at state: 278, token: AND
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 169)
Conflict at state: 278, token: OR
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 170)
Conflict at state: 278, token: QUESTION
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 171)
Conflict at state: 278, token: ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 185)
Conflict at state: 278, token: ADD_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 186)
Conflict at state: 278, token: SUB_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 187)
Conflict at state: 278, token: MUL_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 188)
Conflict at state: 278, token: DIV_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 189)
Conflict at state: 278, token: AND_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 190)
Conflict at state: 278, token: OR_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 191)
Conflict at state: 278, token: XOR_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 192)
Conflict at state: 278, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 193)
Conflict at state: 278, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 194)
Conflict at state: 278, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 195)
Conflict at state: 278, token: MOD_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 196)
Conflict at state: 278, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 278, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 278, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 278, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 278, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 278, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 278, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 278, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 278, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 278, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 278, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 278, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 278, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 278, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 278, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 278, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 278, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 278, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 278, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 278, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 278, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 278, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 278, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 278, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 278, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 278, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 278, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 278, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 278, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 278, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 278, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 278, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 278, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 278, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 278, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 278, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 278, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 278, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 279, token: DOT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 154)
Conflict at state: 279, token: LBRACK
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 155)
Conflict at state: 279, token: LPAREN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 157)
Conflict at state: 279, token: INC
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 173)
Conflict at state: 279, token: DEC
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 174)
Conflict at state: 279, token: MUL
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 175)
Conflict at state: 279, token: DIV
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 176)
Conflict at state: 279, token: MOD
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 177)
Conflict at state: 279, token: ADD
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 178)
Conflict at state: 279, token: SUB
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 179)
Conflict at state: 279, token: LSHIFT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 161)
Conflict at state: 279, token: GT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 162)
Conflict at state: 279, token: LE
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 180)
Conflict at state: 279, token: GE
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 181)
Conflict at state: 279, token: LT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 182)
Conflict at state: 279, token: INSTANCEOF
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 164)
Conflict at state: 279, token: EQUAL
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 183)
Conflict at state: 279, token: NOTEQUAL
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 184)
Conflict at state: 279, token: BITAND
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 166)
Conflict at state: 279, token: CARET
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 167)
Conflict at state: 279, token: BITOR
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 168)
Conflict at state: 279, token: AND
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 169)
Conflict at state: 279, token: OR
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 170)
Conflict at state: 279, token: QUESTION
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 171)
Conflict at state: 279, token: ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 185)
Conflict at state: 279, token: ADD_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 186)
Conflict at state: 279, token: SUB_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 187)
Conflict at state: 279, token: MUL_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 188)
Conflict at state: 279, token: DIV_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 189)
Conflict at state: 279, token: AND_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 190)
Conflict at state: 279, token: OR_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 191)
Conflict at state: 279, token: XOR_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 192)
Conflict at state: 279, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 193)
Conflict at state: 279, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 194)
Conflict at state: 279, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 195)
Conflict at state: 279, token: MOD_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 196)
Conflict at state: 279, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 279, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 279, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 279, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 279, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 279, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 279, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 279, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 279, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 279, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 279, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 279, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 279, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 279, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 279, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 279, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 279, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 279, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 279, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 279, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 279, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 279, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 279, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 279, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 279, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 279, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 279, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 279, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 279, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 279, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 279, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 279, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 279, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 279, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 279, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 279, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 279, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 279, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 280, token: DOT
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 154)
Conflict at state: 280, token: LBRACK
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 155)
Conflict at state: 280, token: LPAREN
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 157)
Conflict at state: 280, token: INC
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 173)
Conflict at state: 280, token: DEC
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 174)
Conflict at state: 280, token: GT
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 162)
Conflict at state: 280, token: LE
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 180)
Conflict at state: 280, token: GE
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 181)
Conflict at state: 280, token: LT
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 182)
Conflict at state: 280, token: INSTANCEOF
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 164)
Conflict at state: 280, token: EQUAL
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 183)
Conflict at state: 280, token: NOTEQUAL
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 184)
Conflict at state: 280, token: BITAND
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 166)
Conflict at state: 280, token: CARET
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 167)
Conflict at state: 280, token: BITOR
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 168)
Conflict at state: 280, token: AND
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 169)
Conflict at state: 280, token: OR
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 170)
Conflict at state: 280, token: QUESTION
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 171)
Conflict at state: 280, token: LSHIFT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 280, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 280, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 280, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 280, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 280, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 280, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 280, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 280, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 280, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 280, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 280, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 280, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 280, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 280, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 280, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 280, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 280, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 280, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 280, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 280, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 280, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 280, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 280, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 280, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 280, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 280, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 280, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 280, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 280, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 280, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 280, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 280, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 280, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 280, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 280, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 280, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 282, token: DOT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 154)
Conflict at state: 282, token: LBRACK
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 155)
Conflict at state: 282, token: LPAREN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 157)
Conflict at state: 282, token: INC
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 173)
Conflict at state: 282, token: DEC
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 174)
Conflict at state: 282, token: MUL
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 175)
Conflict at state: 282, token: DIV
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 176)
Conflict at state: 282, token: MOD
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 177)
Conflict at state: 282, token: ADD
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 178)
Conflict at state: 282, token: SUB
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 179)
Conflict at state: 282, token: LSHIFT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 161)
Conflict at state: 282, token: GT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 162)
Conflict at state: 282, token: LE
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 180)
Conflict at state: 282, token: GE
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 181)
Conflict at state: 282, token: LT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 182)
Conflict at state: 282, token: INSTANCEOF
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 164)
Conflict at state: 282, token: EQUAL
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 183)
Conflict at state: 282, token: NOTEQUAL
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 184)
Conflict at state: 282, token: BITAND
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 166)
Conflict at state: 282, token: CARET
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 167)
Conflict at state: 282, token: BITOR
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 168)
Conflict at state: 282, token: AND
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 169)
Conflict at state: 282, token: OR
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 170)
Conflict at state: 282, token: QUESTION
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 171)
Conflict at state: 282, token: ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 185)
Conflict at state: 282, token: ADD_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 186)
Conflict at state: 282, token: SUB_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 187)
Conflict at state: 282, token: MUL_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 188)
Conflict at state: 282, token: DIV_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 189)
Conflict at state: 282, token: AND_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 190)
Conflict at state: 282, token: OR_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 191)
Conflict at state: 282, token: XOR_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 192)
Conflict at state: 282, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 193)
Conflict at state: 282, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 194)
Conflict at state: 282, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 195)
Conflict at state: 282, token: MOD_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 196)
Conflict at state: 282, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 282, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 282, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 282, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 282, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 282, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 282, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 282, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 282, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 282, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 282, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 282, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 282, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 282, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 282, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 282, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 282, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 282, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 282, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 282, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 282, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 282, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 282, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 282, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 282, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 282, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 282, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 282, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 282, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 282, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 282, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 282, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 282, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 282, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 282, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 282, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 282, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 282, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 284, token: DOT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 154)
Conflict at state: 284, token: LBRACK
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 155)
Conflict at state: 284, token: LPAREN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 157)
Conflict at state: 284, token: INC
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 173)
Conflict at state: 284, token: DEC
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 174)
Conflict at state: 284, token: MUL
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 175)
Conflict at state: 284, token: DIV
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 176)
Conflict at state: 284, token: MOD
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 177)
Conflict at state: 284, token: ADD
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 178)
Conflict at state: 284, token: SUB
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 179)
Conflict at state: 284, token: LSHIFT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 161)
Conflict at state: 284, token: GT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 162)
Conflict at state: 284, token: LE
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 180)
Conflict at state: 284, token: GE
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 181)
Conflict at state: 284, token: LT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 182)
Conflict at state: 284, token: INSTANCEOF
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 164)
Conflict at state: 284, token: EQUAL
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 183)
Conflict at state: 284, token: NOTEQUAL
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 184)
Conflict at state: 284, token: BITAND
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 166)
Conflict at state: 284, token: CARET
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 167)
Conflict at state: 284, token: BITOR
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 168)
Conflict at state: 284, token: AND
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 169)
Conflict at state: 284, token: OR
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 170)
Conflict at state: 284, token: QUESTION
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 171)
Conflict at state: 284, token: ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 185)
Conflict at state: 284, token: ADD_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 186)
Conflict at state: 284, token: SUB_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 187)
Conflict at state: 284, token: MUL_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 188)
Conflict at state: 284, token: DIV_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 189)
Conflict at state: 284, token: AND_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 190)
Conflict at state: 284, token: OR_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 191)
Conflict at state: 284, token: XOR_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 192)
Conflict at state: 284, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 193)
Conflict at state: 284, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 194)
Conflict at state: 284, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 195)
Conflict at state: 284, token: MOD_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 196)
Conflict at state: 284, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 284, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 284, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 284, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 284, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 284, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 284, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 284, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 284, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 284, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 284, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 284, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 284, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 284, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 284, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 284, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 284, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 284, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 284, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 284, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 284, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 284, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 284, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 284, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 284, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 284, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 284, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 284, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 284, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 284, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 284, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 284, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 284, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 284, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 284, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 284, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 284, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 284, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 285, token: DOT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 154)
Conflict at state: 285, token: LBRACK
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 155)
Conflict at state: 285, token: LPAREN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 157)
Conflict at state: 285, token: INC
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 173)
Conflict at state: 285, token: DEC
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 174)
Conflict at state: 285, token: MUL
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 175)
Conflict at state: 285, token: DIV
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 176)
Conflict at state: 285, token: MOD
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 177)
Conflict at state: 285, token: ADD
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 178)
Conflict at state: 285, token: SUB
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 179)
Conflict at state: 285, token: LSHIFT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 161)
Conflict at state: 285, token: GT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 162)
Conflict at state: 285, token: LE
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 180)
Conflict at state: 285, token: GE
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 181)
Conflict at state: 285, token: LT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 182)
Conflict at state: 285, token: INSTANCEOF
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 164)
Conflict at state: 285, token: EQUAL
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 183)
Conflict at state: 285, token: NOTEQUAL
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 184)
Conflict at state: 285, token: BITAND
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 166)
Conflict at state: 285, token: CARET
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 167)
Conflict at state: 285, token: BITOR
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 168)
Conflict at state: 285, token: AND
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 169)
Conflict at state: 285, token: OR
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 170)
Conflict at state: 285, token: QUESTION
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 171)
Conflict at state: 285, token: ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 185)
Conflict at state: 285, token: ADD_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 186)
Conflict at state: 285, token: SUB_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 187)
Conflict at state: 285, token: MUL_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 188)
Conflict at state: 285, token: DIV_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 189)
Conflict at state: 285, token: AND_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 190)
Conflict at state: 285, token: OR_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 191)
Conflict at state: 285, token: XOR_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 192)
Conflict at state: 285, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 193)
Conflict at state: 285, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 194)
Conflict at state: 285, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 195)
Conflict at state: 285, token: MOD_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 196)
Conflict at state: 285, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 285, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 285, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 285, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 285, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 285, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 285, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 285, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 285, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 285, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 285, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 285, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 285, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 285, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 285, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 285, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 285, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 285, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 285, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 285, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 285, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 285, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 285, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 285, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 285, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 285, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 285, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 285, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 285, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 285, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 285, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 285, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 285, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 285, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 285, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 285, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 285, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 285, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 286, token: DOT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 154)
Conflict at state: 286, token: LBRACK
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 155)
Conflict at state: 286, token: LPAREN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 157)
Conflict at state: 286, token: INC
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 173)
Conflict at state: 286, token: DEC
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 174)
Conflict at state: 286, token: MUL
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 175)
Conflict at state: 286, token: DIV
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 176)
Conflict at state: 286, token: MOD
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 177)
Conflict at state: 286, token: ADD
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 178)
Conflict at state: 286, token: SUB
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 179)
Conflict at state: 286, token: LSHIFT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 161)
Conflict at state: 286, token: GT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 162)
Conflict at state: 286, token: LE
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 180)
Conflict at state: 286, token: GE
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 181)
Conflict at state: 286, token: LT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 182)
Conflict at state: 286, token: INSTANCEOF
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 164)
Conflict at state: 286, token: EQUAL
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 183)
Conflict at state: 286, token: NOTEQUAL
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 184)
Conflict at state: 286, token: BITAND
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 166)
Conflict at state: 286, token: CARET
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 167)
Conflict at state: 286, token: BITOR
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 168)
Conflict at state: 286, token: AND
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 169)
Conflict at state: 286, token: OR
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 170)
Conflict at state: 286, token: QUESTION
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 171)
Conflict at state: 286, token: ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 185)
Conflict at state: 286, token: ADD_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 186)
Conflict at state: 286, token: SUB_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 187)
Conflict at state: 286, token: MUL_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 188)
Conflict at state: 286, token: DIV_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 189)
Conflict at state: 286, token: AND_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 190)
Conflict at state: 286, token: OR_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 191)
Conflict at state: 286, token: XOR_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 192)
Conflict at state: 286, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 193)
Conflict at state: 286, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 194)
Conflict at state: 286, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 195)
Conflict at state: 286, token: MOD_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 196)
Conflict at state: 286, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 286, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 286, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 286, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 286, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 286, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 286, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 286, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 286, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 286, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 286, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 286, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 286, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 286, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 286, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 286, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 286, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 286, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 286, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 286, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 286, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 286, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 286, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 286, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 286, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 286, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 286, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 286, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 286, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 286, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 286, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 286, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 286, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 286, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 286, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 286, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 286, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 286, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 287, token: DOT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 154)
Conflict at state: 287, token: LBRACK
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 155)
Conflict at state: 287, token: LPAREN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 157)
Conflict at state: 287, token: INC
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 173)
Conflict at state: 287, token: DEC
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 174)
Conflict at state: 287, token: MUL
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 175)
Conflict at state: 287, token: DIV
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 176)
Conflict at state: 287, token: MOD
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 177)
Conflict at state: 287, token: ADD
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 178)
Conflict at state: 287, token: SUB
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 179)
Conflict at state: 287, token: LSHIFT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 161)
Conflict at state: 287, token: GT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 162)
Conflict at state: 287, token: LE
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 180)
Conflict at state: 287, token: GE
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 181)
Conflict at state: 287, token: LT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 182)
Conflict at state: 287, token: INSTANCEOF
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 164)
Conflict at state: 287, token: EQUAL
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 183)
Conflict at state: 287, token: NOTEQUAL
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 184)
Conflict at state: 287, token: BITAND
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 166)
Conflict at state: 287, token: CARET
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 167)
Conflict at state: 287, token: BITOR
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 168)
Conflict at state: 287, token: AND
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 169)
Conflict at state: 287, token: OR
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 170)
Conflict at state: 287, token: QUESTION
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 171)
Conflict at state: 287, token: ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 185)
Conflict at state: 287, token: ADD_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 186)
Conflict at state: 287, token: SUB_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 187)
Conflict at state: 287, token: MUL_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 188)
Conflict at state: 287, token: DIV_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 189)
Conflict at state: 287, token: AND_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 190)
Conflict at state: 287, token: OR_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 191)
Conflict at state: 287, token: XOR_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 192)
Conflict at state: 287, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 193)
Conflict at state: 287, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 194)
Conflict at state: 287, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 195)
Conflict at state: 287, token: MOD_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 196)
Conflict at state: 287, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 287, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 287, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 287, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 287, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 287, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 287, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 287, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 287, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 287, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 287, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 287, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 287, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 287, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 287, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 287, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 287, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 287, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 287, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 287, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 287, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 287, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 287, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 287, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 287, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 287, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 287, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 287, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 287, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 287, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 287, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 287, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 287, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 287, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 287, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 287, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 287, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 287, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 288, token: DOT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 154)
Conflict at state: 288, token: LBRACK
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 155)
Conflict at state: 288, token: LPAREN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 157)
Conflict at state: 288, token: INC
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 173)
Conflict at state: 288, token: DEC
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 174)
Conflict at state: 288, token: MUL
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 175)
Conflict at state: 288, token: DIV
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 176)
Conflict at state: 288, token: MOD
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 177)
Conflict at state: 288, token: ADD
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 178)
Conflict at state: 288, token: SUB
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 179)
Conflict at state: 288, token: LSHIFT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 161)
Conflict at state: 288, token: GT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 162)
Conflict at state: 288, token: LE
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 180)
Conflict at state: 288, token: GE
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 181)
Conflict at state: 288, token: LT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 182)
Conflict at state: 288, token: INSTANCEOF
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 164)
Conflict at state: 288, token: EQUAL
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 183)
Conflict at state: 288, token: NOTEQUAL
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 184)
Conflict at state: 288, token: BITAND
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 166)
Conflict at state: 288, token: CARET
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 167)
Conflict at state: 288, token: BITOR
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 168)
Conflict at state: 288, token: AND
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 169)
Conflict at state: 288, token: OR
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 170)
Conflict at state: 288, token: QUESTION
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 171)
Conflict at state: 288, token: ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 185)
Conflict at state: 288, token: ADD_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 186)
Conflict at state: 288, token: SUB_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 187)
Conflict at state: 288, token: MUL_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 188)
Conflict at state: 288, token: DIV_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 189)
Conflict at state: 288, token: AND_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 190)
Conflict at state: 288, token: OR_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 191)
Conflict at state: 288, token: XOR_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 192)
Conflict at state: 288, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 193)
Conflict at state: 288, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 194)
Conflict at state: 288, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 195)
Conflict at state: 288, token: MOD_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 196)
Conflict at state: 288, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 288, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 288, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 288, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 288, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 288, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 288, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 288, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 288, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 288, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 288, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 288, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 288, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 288, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 288, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 288, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 288, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 288, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 288, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 288, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 288, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 288, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 288, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 288, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 288, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 288, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 288, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 288, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 288, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 288, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 288, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 288, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 288, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 288, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 288, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 288, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 288, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 288, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 289, token: DOT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 154)
Conflict at state: 289, token: LBRACK
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 155)
Conflict at state: 289, token: LPAREN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 157)
Conflict at state: 289, token: INC
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 173)
Conflict at state: 289, token: DEC
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 174)
Conflict at state: 289, token: MUL
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 175)
Conflict at state: 289, token: DIV
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 176)
Conflict at state: 289, token: MOD
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 177)
Conflict at state: 289, token: ADD
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 178)
Conflict at state: 289, token: SUB
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 179)
Conflict at state: 289, token: LSHIFT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 161)
Conflict at state: 289, token: GT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 162)
Conflict at state: 289, token: LE
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 180)
Conflict at state: 289, token: GE
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 181)
Conflict at state: 289, token: LT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 182)
Conflict at state: 289, token: INSTANCEOF
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 164)
Conflict at state: 289, token: EQUAL
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 183)
Conflict at state: 289, token: NOTEQUAL
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 184)
Conflict at state: 289, token: BITAND
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 166)
Conflict at state: 289, token: CARET
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 167)
Conflict at state: 289, token: BITOR
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 168)
Conflict at state: 289, token: AND
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 169)
Conflict at state: 289, token: OR
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 170)
Conflict at state: 289, token: QUESTION
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 171)
Conflict at state: 289, token: ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 185)
Conflict at state: 289, token: ADD_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 186)
Conflict at state: 289, token: SUB_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 187)
Conflict at state: 289, token: MUL_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 188)
Conflict at state: 289, token: DIV_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 189)
Conflict at state: 289, token: AND_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 190)
Conflict at state: 289, token: OR_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 191)
Conflict at state: 289, token: XOR_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 192)
Conflict at state: 289, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 193)
Conflict at state: 289, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 194)
Conflict at state: 289, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 195)
Conflict at state: 289, token: MOD_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 196)
Conflict at state: 289, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 289, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 289, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 289, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 289, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 289, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 289, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 289, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 289, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 289, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 289, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 289, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 289, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 289, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 289, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 289, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 289, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 289, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 289, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 289, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 289, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 289, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 289, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 289, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 289, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 289, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 289, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 289, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 289, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 289, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 289, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 289, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 289, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 289, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 289, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 289, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 289, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 289, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 290, token: COLON
  reduce by rule: expression -> expression
  shift token (then go to state 394)
Conflict at state: 290, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 290, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 290, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 290, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 290, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 290, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 290, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 290, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 290, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 290, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 290, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 290, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 290, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 290, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 290, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 290, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 290, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 290, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 290, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 290, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 290, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 290, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 290, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 290, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 290, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 290, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 290, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 290, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 290, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 290, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 290, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 290, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 290, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 290, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 290, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 290, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 291, token: DOT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 154)
Conflict at state: 291, token: LBRACK
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 155)
Conflict at state: 291, token: LPAREN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 157)
Conflict at state: 291, token: INC
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 173)
Conflict at state: 291, token: DEC
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 174)
Conflict at state: 291, token: MUL
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 175)
Conflict at state: 291, token: DIV
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 176)
Conflict at state: 291, token: MOD
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 177)
Conflict at state: 291, token: ADD
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 178)
Conflict at state: 291, token: SUB
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 179)
Conflict at state: 291, token: LSHIFT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 161)
Conflict at state: 291, token: GT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 162)
Conflict at state: 291, token: LE
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 180)
Conflict at state: 291, token: GE
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 181)
Conflict at state: 291, token: LT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 182)
Conflict at state: 291, token: INSTANCEOF
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 164)
Conflict at state: 291, token: EQUAL
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 183)
Conflict at state: 291, token: NOTEQUAL
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 184)
Conflict at state: 291, token: BITAND
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 166)
Conflict at state: 291, token: CARET
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 167)
Conflict at state: 291, token: BITOR
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 168)
Conflict at state: 291, token: AND
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 169)
Conflict at state: 291, token: OR
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 170)
Conflict at state: 291, token: QUESTION
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 171)
Conflict at state: 291, token: ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 185)
Conflict at state: 291, token: ADD_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 186)
Conflict at state: 291, token: SUB_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 187)
Conflict at state: 291, token: MUL_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 188)
Conflict at state: 291, token: DIV_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 189)
Conflict at state: 291, token: AND_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 190)
Conflict at state: 291, token: OR_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 191)
Conflict at state: 291, token: XOR_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 192)
Conflict at state: 291, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 193)
Conflict at state: 291, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 194)
Conflict at state: 291, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 195)
Conflict at state: 291, token: MOD_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 196)
Conflict at state: 291, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 291, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 291, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 291, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 291, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 291, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 291, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 291, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 291, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 291, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 291, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 291, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 291, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 291, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 291, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 291, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 291, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 291, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 291, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 291, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 291, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 291, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 291, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 291, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 291, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 291, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 291, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 291, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 291, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 291, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 291, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 291, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 291, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 291, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 291, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 291, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 291, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 291, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 295, token: DOT
  reduce by rule: expression -> qualifiedName DOT SUPER
  shift token (then go to state 395)
Conflict at state: 302, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 398)
Conflict at state: 302, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 302, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 302, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 302, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 302, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 302, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 302, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 302, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 302, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 302, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 302, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 302, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 302, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 302, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 302, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 302, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 302, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 302, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 302, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 302, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 302, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 302, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 302, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 302, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 302, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 302, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 302, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 302, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 302, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 302, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 302, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 302, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 302, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 302, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 302, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 302, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 313, token: RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: Identifier
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: THIS
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SUPER
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: IntegerLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: FloatingPointLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: CharacterLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: StringLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BooleanLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: NullLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: VOID
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BOOLEAN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: CHAR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BYTE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SHORT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: INT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LONG
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: FLOAT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DOUBLE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: NEW
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ADD
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SUB
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: INC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DEC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: TILDE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BANG
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: TEMPLATE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: COMMA
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: MOD_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LSHIFT_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: URSHIFT_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: RSHIFT_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: XOR_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: OR_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: AND_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DIV_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: MUL_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SUB_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ADD_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: QUESTION
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: OR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: AND
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BITOR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: CARET
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BITAND
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: NOTEQUAL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: EQUAL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: INSTANCEOF
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: GE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: GT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LSHIFT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: MOD
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DIV
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: MUL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LBRACK
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DOT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: RBRACE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: COLON
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SEMI
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: RBRACK
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: WHILE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ASSERT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: IF
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: FOR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DO
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: TRY
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SWITCH
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: SYNCHRONIZED
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: RETURN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: THROW
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: BREAK
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: CONTINUE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: AT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: STATIC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: FINAL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ABSTRACT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: STRICTFP
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: TRANSIENT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: VOLATILE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: PUBLIC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: PRIVATE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: PROTECTED
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: NATIVE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: CLASS
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: INTERFACE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ENUM
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: LBRACE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: DEFAULT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: CASE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 313, token: ELSE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 323, token: LBRACK
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 410)
Conflict at state: 324, token: LBRACE
  reduce by rule: classCreatorRest -> arguments
  shift token (then go to state 239)
Conflict at state: 387, token: Identifier
  reduce by rule: optionalNonWildcardTypeArguments -> nonWildcardTypeArguments
  shift token (then go to state 49)
Conflict at state: 392, token: DOT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 154)
Conflict at state: 392, token: LBRACK
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 155)
Conflict at state: 392, token: LPAREN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 157)
Conflict at state: 392, token: INC
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 173)
Conflict at state: 392, token: DEC
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 174)
Conflict at state: 392, token: MUL
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 175)
Conflict at state: 392, token: DIV
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 176)
Conflict at state: 392, token: MOD
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 177)
Conflict at state: 392, token: ADD
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 178)
Conflict at state: 392, token: SUB
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 179)
Conflict at state: 392, token: LSHIFT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 161)
Conflict at state: 392, token: GT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 162)
Conflict at state: 392, token: LE
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 180)
Conflict at state: 392, token: GE
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 181)
Conflict at state: 392, token: LT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 182)
Conflict at state: 392, token: INSTANCEOF
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 164)
Conflict at state: 392, token: EQUAL
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 183)
Conflict at state: 392, token: NOTEQUAL
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 184)
Conflict at state: 392, token: BITAND
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 166)
Conflict at state: 392, token: CARET
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 167)
Conflict at state: 392, token: BITOR
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 168)
Conflict at state: 392, token: AND
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 169)
Conflict at state: 392, token: OR
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 170)
Conflict at state: 392, token: QUESTION
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 171)
Conflict at state: 392, token: ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 185)
Conflict at state: 392, token: ADD_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 186)
Conflict at state: 392, token: SUB_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 187)
Conflict at state: 392, token: MUL_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 188)
Conflict at state: 392, token: DIV_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 189)
Conflict at state: 392, token: AND_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 190)
Conflict at state: 392, token: OR_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 191)
Conflict at state: 392, token: XOR_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 192)
Conflict at state: 392, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 193)
Conflict at state: 392, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 194)
Conflict at state: 392, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 195)
Conflict at state: 392, token: MOD_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 196)
Conflict at state: 392, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 392, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 392, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 392, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 392, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 392, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 392, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 392, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 392, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 392, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 392, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 392, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 392, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 392, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 392, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 392, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 392, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 392, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 392, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 392, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 392, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 392, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 392, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 392, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 392, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 392, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 392, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 392, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 392, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 392, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 392, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 392, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 392, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 392, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 392, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 392, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 392, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 392, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 401, token: LPAREN
  reduce by rule: superSuffix -> DOT Identifier
  shift token (then go to state 308)
Conflict at state: 408, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 494)
Conflict at state: 408, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 408, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 408, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 408, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 408, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 408, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 408, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 408, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 408, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 408, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 408, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 408, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 408, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 408, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 408, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 408, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 408, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 408, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 408, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 408, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 408, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 408, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 408, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 408, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 408, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 408, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 408, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 408, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 408, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 408, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 408, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 408, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 408, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 408, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 408, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 408, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 412, token: LBRACE
  reduce by rule: classCreatorRest -> LPAREN RPAREN
  shift token (then go to state 239)
Conflict at state: 412, token: RPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: DOT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: RBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: DEC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: INC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: RBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: MOD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: DIV
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: MUL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SUB
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ADD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LSHIFT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: GE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: GT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: NOTEQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: EQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: INSTANCEOF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BITAND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: CARET
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BITOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: AND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: OR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: COLON
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: MOD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: URSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: RSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: XOR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: OR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: AND_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: DIV_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: MUL_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SUB_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ADD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: QUESTION
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: COMMA
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SEMI
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: WHILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ASSERT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: IF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: FOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: DO
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: TRY
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SWITCH
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SYNCHRONIZED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: RETURN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: THROW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BREAK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: CONTINUE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: Identifier
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: THIS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SUPER
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: IntegerLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: FloatingPointLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: CharacterLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: StringLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BooleanLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: NullLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: VOID
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BOOLEAN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: CHAR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BYTE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: SHORT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: INT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LONG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: FLOAT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: DOUBLE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: NEW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: TILDE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: BANG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: TEMPLATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: AT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: STATIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: FINAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ABSTRACT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: STRICTFP
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: TRANSIENT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: VOLATILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: PUBLIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: PRIVATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: PROTECTED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: NATIVE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: CLASS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: INTERFACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ENUM
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: LBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  shift token (then go to state 239)
Conflict at state: 412, token: DEFAULT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: CASE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 412, token: ELSE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 458, token: SEMI
  reduce by rule: expression -> expression
  shift token (then go to state 547)
Conflict at state: 458, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 458, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 458, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 458, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 458, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 458, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 458, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 458, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 458, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 458, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 458, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 458, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 458, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 458, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 458, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 458, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 458, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 458, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 458, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 458, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 458, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 458, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 458, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 458, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 458, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 458, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 458, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 458, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 458, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 458, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 458, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 458, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 458, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 458, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 458, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 458, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 461, token: DOT
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 201)
Conflict at state: 461, token: LBRACK
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 203)
Conflict at state: 471, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 558)
Conflict at state: 474, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 562)
Conflict at state: 482, token: DOT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 154)
Conflict at state: 482, token: LBRACK
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 155)
Conflict at state: 482, token: LPAREN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 157)
Conflict at state: 482, token: INC
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 173)
Conflict at state: 482, token: DEC
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 174)
Conflict at state: 482, token: MUL
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 175)
Conflict at state: 482, token: DIV
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 176)
Conflict at state: 482, token: MOD
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 177)
Conflict at state: 482, token: ADD
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 178)
Conflict at state: 482, token: SUB
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 179)
Conflict at state: 482, token: LSHIFT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 161)
Conflict at state: 482, token: GT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 162)
Conflict at state: 482, token: LE
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 180)
Conflict at state: 482, token: GE
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 181)
Conflict at state: 482, token: LT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 182)
Conflict at state: 482, token: INSTANCEOF
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 164)
Conflict at state: 482, token: EQUAL
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 183)
Conflict at state: 482, token: NOTEQUAL
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 184)
Conflict at state: 482, token: BITAND
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 166)
Conflict at state: 482, token: CARET
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 167)
Conflict at state: 482, token: BITOR
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 168)
Conflict at state: 482, token: AND
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 169)
Conflict at state: 482, token: OR
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 170)
Conflict at state: 482, token: QUESTION
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 171)
Conflict at state: 482, token: ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 185)
Conflict at state: 482, token: ADD_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 186)
Conflict at state: 482, token: SUB_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 187)
Conflict at state: 482, token: MUL_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 188)
Conflict at state: 482, token: DIV_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 189)
Conflict at state: 482, token: AND_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 190)
Conflict at state: 482, token: OR_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 191)
Conflict at state: 482, token: XOR_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 192)
Conflict at state: 482, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 193)
Conflict at state: 482, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 194)
Conflict at state: 482, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 195)
Conflict at state: 482, token: MOD_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 196)
Conflict at state: 482, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 482, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 482, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 482, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 482, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 482, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 482, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 482, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 482, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 482, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 482, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 482, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 482, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 482, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 482, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 482, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 482, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 482, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 482, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 482, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 482, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 482, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 482, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 482, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 482, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 482, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 482, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 482, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 482, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 482, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 482, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 482, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 482, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 482, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 482, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 482, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 482, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 482, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 483, token: DOT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: RPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: RBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: INC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: DEC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: COMMA
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: RBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: MUL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: DIV
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: MOD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ADD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SUB
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LSHIFT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: GT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: GE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: INSTANCEOF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: EQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: NOTEQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BITAND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: CARET
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BITOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: AND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: OR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: COLON
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: QUESTION
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ADD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SUB_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: MUL_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: DIV_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: AND_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: OR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: XOR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: RSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: URSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: MOD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SEMI
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ENUM
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: INTERFACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: CLASS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: NATIVE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: PROTECTED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: PRIVATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: PUBLIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: VOLATILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: TRANSIENT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: STRICTFP
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ABSTRACT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: FINAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: STATIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: AT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: TEMPLATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BANG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: TILDE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: NEW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: DOUBLE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: FLOAT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: LONG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: INT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SHORT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BYTE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: CHAR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BOOLEAN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: VOID
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: NullLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BooleanLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: StringLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: CharacterLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: FloatingPointLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: IntegerLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SUPER
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: THIS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: Identifier
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: CONTINUE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: BREAK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: THROW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: RETURN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SYNCHRONIZED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: SWITCH
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: TRY
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: DO
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: WHILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: FOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: IF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ASSERT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: ELSE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: DEFAULT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 483, token: CASE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 487, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expressionList COMMA expression
Conflict at state: 487, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expressionList COMMA expression
Conflict at state: 487, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 487, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 487, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 487, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 487, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 487, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 487, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 487, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 487, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 487, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 487, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 487, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 487, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 487, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 487, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 487, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 487, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 487, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 487, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 487, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 487, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 487, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 487, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 487, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 487, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 487, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 487, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 487, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 487, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 487, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 487, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 487, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 487, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 487, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 487, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 487, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 487, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expressionList COMMA expression
Conflict at state: 488, token: DOT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 154)
Conflict at state: 488, token: LBRACK
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 155)
Conflict at state: 488, token: LPAREN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 157)
Conflict at state: 488, token: INC
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 173)
Conflict at state: 488, token: DEC
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 174)
Conflict at state: 488, token: MUL
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 175)
Conflict at state: 488, token: DIV
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 176)
Conflict at state: 488, token: MOD
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 177)
Conflict at state: 488, token: ADD
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 178)
Conflict at state: 488, token: SUB
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 179)
Conflict at state: 488, token: LSHIFT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 161)
Conflict at state: 488, token: GT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 162)
Conflict at state: 488, token: LE
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 180)
Conflict at state: 488, token: GE
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 181)
Conflict at state: 488, token: LT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 182)
Conflict at state: 488, token: INSTANCEOF
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 164)
Conflict at state: 488, token: EQUAL
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 183)
Conflict at state: 488, token: NOTEQUAL
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 184)
Conflict at state: 488, token: BITAND
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 166)
Conflict at state: 488, token: CARET
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 167)
Conflict at state: 488, token: BITOR
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 168)
Conflict at state: 488, token: AND
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 169)
Conflict at state: 488, token: OR
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 170)
Conflict at state: 488, token: QUESTION
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 171)
Conflict at state: 488, token: ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 185)
Conflict at state: 488, token: ADD_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 186)
Conflict at state: 488, token: SUB_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 187)
Conflict at state: 488, token: MUL_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 188)
Conflict at state: 488, token: DIV_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 189)
Conflict at state: 488, token: AND_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 190)
Conflict at state: 488, token: OR_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 191)
Conflict at state: 488, token: XOR_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 192)
Conflict at state: 488, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 193)
Conflict at state: 488, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 194)
Conflict at state: 488, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 195)
Conflict at state: 488, token: MOD_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 196)
Conflict at state: 488, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 488, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 488, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 488, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 488, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 488, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 488, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 488, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 488, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 488, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 488, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 488, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 488, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 488, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 488, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 488, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 488, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 488, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 488, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 488, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 488, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 488, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 488, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 488, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 488, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 488, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 488, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 488, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 488, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 488, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 488, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 488, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 488, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 488, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 488, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 488, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 488, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 488, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 489, token: DOT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 154)
Conflict at state: 489, token: LBRACK
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 155)
Conflict at state: 489, token: LPAREN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 157)
Conflict at state: 489, token: INC
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 173)
Conflict at state: 489, token: DEC
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 174)
Conflict at state: 489, token: MUL
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 175)
Conflict at state: 489, token: DIV
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 176)
Conflict at state: 489, token: MOD
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 177)
Conflict at state: 489, token: ADD
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 178)
Conflict at state: 489, token: SUB
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 179)
Conflict at state: 489, token: LSHIFT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 161)
Conflict at state: 489, token: GT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 162)
Conflict at state: 489, token: LE
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 180)
Conflict at state: 489, token: GE
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 181)
Conflict at state: 489, token: LT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 182)
Conflict at state: 489, token: INSTANCEOF
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 164)
Conflict at state: 489, token: EQUAL
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 183)
Conflict at state: 489, token: NOTEQUAL
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 184)
Conflict at state: 489, token: BITAND
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 166)
Conflict at state: 489, token: CARET
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 167)
Conflict at state: 489, token: BITOR
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 168)
Conflict at state: 489, token: AND
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 169)
Conflict at state: 489, token: OR
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 170)
Conflict at state: 489, token: QUESTION
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 171)
Conflict at state: 489, token: ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 185)
Conflict at state: 489, token: ADD_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 186)
Conflict at state: 489, token: SUB_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 187)
Conflict at state: 489, token: MUL_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 188)
Conflict at state: 489, token: DIV_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 189)
Conflict at state: 489, token: AND_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 190)
Conflict at state: 489, token: OR_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 191)
Conflict at state: 489, token: XOR_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 192)
Conflict at state: 489, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 193)
Conflict at state: 489, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 194)
Conflict at state: 489, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 195)
Conflict at state: 489, token: MOD_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 196)
Conflict at state: 489, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 489, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 489, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 489, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 489, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 489, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 489, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 489, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 489, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 489, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 489, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 489, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 489, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 489, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 489, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 489, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 489, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 489, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 489, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 489, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 489, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 489, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 489, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 489, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 489, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 489, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 489, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 489, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 489, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 489, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 489, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 489, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 489, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 489, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 489, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 489, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 489, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 489, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 490, token: DOT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 154)
Conflict at state: 490, token: LBRACK
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 155)
Conflict at state: 490, token: LPAREN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 157)
Conflict at state: 490, token: INC
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 173)
Conflict at state: 490, token: DEC
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 174)
Conflict at state: 490, token: MUL
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 175)
Conflict at state: 490, token: DIV
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 176)
Conflict at state: 490, token: MOD
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 177)
Conflict at state: 490, token: ADD
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 178)
Conflict at state: 490, token: SUB
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 179)
Conflict at state: 490, token: LSHIFT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 161)
Conflict at state: 490, token: GT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 162)
Conflict at state: 490, token: LE
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 180)
Conflict at state: 490, token: GE
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 181)
Conflict at state: 490, token: LT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 182)
Conflict at state: 490, token: INSTANCEOF
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 164)
Conflict at state: 490, token: EQUAL
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 183)
Conflict at state: 490, token: NOTEQUAL
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 184)
Conflict at state: 490, token: BITAND
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 166)
Conflict at state: 490, token: CARET
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 167)
Conflict at state: 490, token: BITOR
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 168)
Conflict at state: 490, token: AND
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 169)
Conflict at state: 490, token: OR
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 170)
Conflict at state: 490, token: QUESTION
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 171)
Conflict at state: 490, token: ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 185)
Conflict at state: 490, token: ADD_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 186)
Conflict at state: 490, token: SUB_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 187)
Conflict at state: 490, token: MUL_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 188)
Conflict at state: 490, token: DIV_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 189)
Conflict at state: 490, token: AND_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 190)
Conflict at state: 490, token: OR_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 191)
Conflict at state: 490, token: XOR_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 192)
Conflict at state: 490, token: RSHIFT_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 193)
Conflict at state: 490, token: URSHIFT_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 194)
Conflict at state: 490, token: LSHIFT_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 195)
Conflict at state: 490, token: MOD_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 196)
Conflict at state: 490, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 490, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 490, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 490, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 490, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 490, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 490, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 490, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 490, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 490, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 490, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 490, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 490, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 490, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 490, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 490, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 490, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 490, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 490, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 490, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 490, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 490, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 490, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 490, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 490, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 490, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 490, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 490, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 490, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 490, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 490, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 490, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 490, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 490, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 490, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 490, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 490, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 490, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 495, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 574)
Conflict at state: 495, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 495, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 495, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 495, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 495, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 495, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 495, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 495, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 495, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 495, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 495, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 495, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 495, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 495, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 495, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 495, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 495, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 495, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 495, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 495, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 495, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 495, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 495, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 495, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 495, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 495, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 495, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 495, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 495, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 495, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 495, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 495, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 495, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 495, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 495, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 495, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 503, token: DEC
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 174)
Conflict at state: 503, token: INC
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 173)
Conflict at state: 503, token: SUB
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 179)
Conflict at state: 503, token: ADD
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 178)
Conflict at state: 503, token: LPAREN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 157)
Conflict at state: 503, token: DOT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 154)
Conflict at state: 503, token: LBRACK
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 155)
Conflict at state: 503, token: MUL
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 175)
Conflict at state: 503, token: DIV
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 176)
Conflict at state: 503, token: MOD
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 177)
Conflict at state: 503, token: LSHIFT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 161)
Conflict at state: 503, token: GT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 162)
Conflict at state: 503, token: LE
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 180)
Conflict at state: 503, token: GE
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 181)
Conflict at state: 503, token: LT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 182)
Conflict at state: 503, token: INSTANCEOF
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 164)
Conflict at state: 503, token: EQUAL
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 183)
Conflict at state: 503, token: NOTEQUAL
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 184)
Conflict at state: 503, token: BITAND
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 166)
Conflict at state: 503, token: CARET
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 167)
Conflict at state: 503, token: BITOR
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 168)
Conflict at state: 503, token: AND
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 169)
Conflict at state: 503, token: OR
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 170)
Conflict at state: 503, token: QUESTION
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 171)
Conflict at state: 503, token: ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 185)
Conflict at state: 503, token: ADD_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 186)
Conflict at state: 503, token: SUB_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 187)
Conflict at state: 503, token: MUL_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 188)
Conflict at state: 503, token: DIV_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 189)
Conflict at state: 503, token: AND_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 190)
Conflict at state: 503, token: OR_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 191)
Conflict at state: 503, token: XOR_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 192)
Conflict at state: 503, token: RSHIFT_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 193)
Conflict at state: 503, token: URSHIFT_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 194)
Conflict at state: 503, token: LSHIFT_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 195)
Conflict at state: 503, token: MOD_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 196)
Conflict at state: 503, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: AT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 503, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 503, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 503, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 503, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: INT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 503, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: DO
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: IF
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 503, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 503, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 503, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 503, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 503, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 503, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 503, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 503, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 503, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 503, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 503, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 503, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 503, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 503, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 503, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 503, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 503, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 503, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 503, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 503, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 503, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 503, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 503, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 503, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 503, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 503, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 503, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 503, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 503, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 503, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 503, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 508, token: LBRACE
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 363)
Conflict at state: 508, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 583)
Conflict at state: 509, token: LBRACE
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 363)
Conflict at state: 509, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 586)
Conflict at state: 530, token: COLON
  reduce by rule: assertExpression -> expression
  shift token (then go to state 602)
Conflict at state: 530, token: DOT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 154)
Conflict at state: 530, token: LBRACK
  reduce by rule: assertExpression -> expression
  shift token (then go to state 155)
Conflict at state: 530, token: LPAREN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 157)
Conflict at state: 530, token: INC
  reduce by rule: assertExpression -> expression
  shift token (then go to state 173)
Conflict at state: 530, token: DEC
  reduce by rule: assertExpression -> expression
  shift token (then go to state 174)
Conflict at state: 530, token: MUL
  reduce by rule: assertExpression -> expression
  shift token (then go to state 175)
Conflict at state: 530, token: DIV
  reduce by rule: assertExpression -> expression
  shift token (then go to state 176)
Conflict at state: 530, token: MOD
  reduce by rule: assertExpression -> expression
  shift token (then go to state 177)
Conflict at state: 530, token: ADD
  reduce by rule: assertExpression -> expression
  shift token (then go to state 178)
Conflict at state: 530, token: SUB
  reduce by rule: assertExpression -> expression
  shift token (then go to state 179)
Conflict at state: 530, token: LSHIFT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 161)
Conflict at state: 530, token: GT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 162)
Conflict at state: 530, token: LE
  reduce by rule: assertExpression -> expression
  shift token (then go to state 180)
Conflict at state: 530, token: GE
  reduce by rule: assertExpression -> expression
  shift token (then go to state 181)
Conflict at state: 530, token: LT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 182)
Conflict at state: 530, token: INSTANCEOF
  reduce by rule: assertExpression -> expression
  shift token (then go to state 164)
Conflict at state: 530, token: EQUAL
  reduce by rule: assertExpression -> expression
  shift token (then go to state 183)
Conflict at state: 530, token: NOTEQUAL
  reduce by rule: assertExpression -> expression
  shift token (then go to state 184)
Conflict at state: 530, token: BITAND
  reduce by rule: assertExpression -> expression
  shift token (then go to state 166)
Conflict at state: 530, token: CARET
  reduce by rule: assertExpression -> expression
  shift token (then go to state 167)
Conflict at state: 530, token: BITOR
  reduce by rule: assertExpression -> expression
  shift token (then go to state 168)
Conflict at state: 530, token: AND
  reduce by rule: assertExpression -> expression
  shift token (then go to state 169)
Conflict at state: 530, token: OR
  reduce by rule: assertExpression -> expression
  shift token (then go to state 170)
Conflict at state: 530, token: QUESTION
  reduce by rule: assertExpression -> expression
  shift token (then go to state 171)
Conflict at state: 530, token: ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 185)
Conflict at state: 530, token: ADD_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 186)
Conflict at state: 530, token: SUB_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 187)
Conflict at state: 530, token: MUL_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 188)
Conflict at state: 530, token: DIV_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 189)
Conflict at state: 530, token: AND_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 190)
Conflict at state: 530, token: OR_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 191)
Conflict at state: 530, token: XOR_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 192)
Conflict at state: 530, token: RSHIFT_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 193)
Conflict at state: 530, token: URSHIFT_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 194)
Conflict at state: 530, token: LSHIFT_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 195)
Conflict at state: 530, token: MOD_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 196)
Conflict at state: 530, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: assertExpression -> expression
Conflict at state: 530, token: COLON
  reduce by rule: expression -> expression
  shift token (then go to state 602)
Conflict at state: 530, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 530, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 530, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 530, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 530, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 530, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 530, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 530, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 530, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 530, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 530, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 530, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 530, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 530, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 530, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 530, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 530, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 530, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 530, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 530, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 530, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 530, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 530, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 530, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 530, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 530, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 530, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 530, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 530, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 530, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 530, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 530, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 530, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 530, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 530, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 530, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 541, token: SEMI
  reduce by rule: expression -> expression
  shift token (then go to state 629)
Conflict at state: 541, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 541, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 541, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 541, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 541, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 541, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 541, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 541, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 541, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 541, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 541, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 541, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 541, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 541, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 541, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 541, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 541, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 541, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 541, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 541, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 541, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 541, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 541, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 541, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 541, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 541, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 541, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 541, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 541, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 541, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 541, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 541, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 541, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 541, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 541, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 541, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 542, token: SEMI
  reduce by rule: expression -> expression
  shift token (then go to state 630)
Conflict at state: 542, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 542, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 542, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 542, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 542, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 542, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 542, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 542, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 542, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 542, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 542, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 542, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 542, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 542, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 542, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 542, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 542, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 542, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 542, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 542, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 542, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 542, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 542, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 542, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 542, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 542, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 542, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 542, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 542, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 542, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 542, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 542, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 542, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 542, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 542, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 542, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 557, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 637)
Conflict at state: 561, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 640)
Conflict at state: 563, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 642)
Conflict at state: 564, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 644)
Conflict at state: 581, token: LBRACE
  reduce by rule: throwsList -> 
  shift token (then go to state 363)
Conflict at state: 581, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 654)
Conflict at state: 584, token: LBRACE
  reduce by rule: throwsList -> 
  shift token (then go to state 363)
Conflict at state: 584, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 657)
Conflict at state: 587, token: LBRACE
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 363)
Conflict at state: 587, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 660)
Conflict at state: 588, token: LBRACE
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 363)
Conflict at state: 588, token: SEMI
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 663)
Conflict at state: 603, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 672)
Conflict at state: 603, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 603, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 603, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 603, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 603, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 603, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 603, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 603, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 603, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 603, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 603, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 603, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 603, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 603, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 603, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 603, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 603, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 603, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 603, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 603, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 603, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 603, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 603, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 603, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 603, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 603, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 603, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 603, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 603, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 603, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 603, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 603, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 603, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 603, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 603, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 603, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 613, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 681)
Conflict at state: 613, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 613, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 613, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 613, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 613, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 613, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 613, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 613, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 613, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 613, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 613, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 613, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 613, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 613, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 613, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 613, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 613, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 613, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 613, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 613, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 613, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 613, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 613, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 613, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 613, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 613, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 613, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 613, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 613, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 613, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 613, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 613, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 613, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 613, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 613, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 613, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 627, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 695)
Conflict at state: 627, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 627, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 627, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 627, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 627, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 627, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 627, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 627, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 627, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 627, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 627, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 627, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 627, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 627, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 627, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 627, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 627, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 627, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 627, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 627, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 627, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 627, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 627, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 627, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 627, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 627, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 627, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 627, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 627, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 627, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 627, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 627, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 627, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 627, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 627, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 627, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 628, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 696)
Conflict at state: 628, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 628, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 628, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 628, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 628, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 628, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 628, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 628, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 628, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 628, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 628, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 628, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 628, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 628, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 628, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 628, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 628, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 628, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 628, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 628, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 628, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 628, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 628, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 628, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 628, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 628, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 628, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 628, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 628, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 628, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 628, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 628, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 628, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 628, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 628, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 628, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 641, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 700)
Conflict at state: 643, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 702)
Conflict at state: 658, token: LBRACE
  reduce by rule: throwsList -> 
  shift token (then go to state 363)
Conflict at state: 658, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 713)
Conflict at state: 661, token: LBRACE
  reduce by rule: throwsList -> 
  shift token (then go to state 363)
Conflict at state: 661, token: SEMI
  reduce by rule: throwsList -> 
  shift token (then go to state 716)
Conflict at state: 671, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: assertExpression -> expression COLON expression
Conflict at state: 671, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 671, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 671, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 671, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 671, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 671, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 671, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 671, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 671, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 671, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 671, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 671, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 671, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 671, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 671, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 671, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 671, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 671, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 671, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 671, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 671, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 671, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 671, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 671, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 671, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 671, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 671, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 671, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 671, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 671, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 671, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 671, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 671, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 671, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 671, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 671, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 676, token: DOT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 154)
Conflict at state: 676, token: LBRACK
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 155)
Conflict at state: 676, token: LPAREN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 157)
Conflict at state: 676, token: INC
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 173)
Conflict at state: 676, token: DEC
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 174)
Conflict at state: 676, token: MUL
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 175)
Conflict at state: 676, token: DIV
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 176)
Conflict at state: 676, token: MOD
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 177)
Conflict at state: 676, token: ADD
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 178)
Conflict at state: 676, token: SUB
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 179)
Conflict at state: 676, token: LSHIFT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 161)
Conflict at state: 676, token: GT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 162)
Conflict at state: 676, token: LE
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 180)
Conflict at state: 676, token: GE
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 181)
Conflict at state: 676, token: LT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 182)
Conflict at state: 676, token: INSTANCEOF
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 164)
Conflict at state: 676, token: EQUAL
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 183)
Conflict at state: 676, token: NOTEQUAL
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 184)
Conflict at state: 676, token: BITAND
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 166)
Conflict at state: 676, token: CARET
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 167)
Conflict at state: 676, token: BITOR
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 168)
Conflict at state: 676, token: AND
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 169)
Conflict at state: 676, token: OR
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 170)
Conflict at state: 676, token: QUESTION
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 171)
Conflict at state: 676, token: ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 185)
Conflict at state: 676, token: ADD_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 186)
Conflict at state: 676, token: SUB_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 187)
Conflict at state: 676, token: MUL_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 188)
Conflict at state: 676, token: DIV_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 189)
Conflict at state: 676, token: AND_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 190)
Conflict at state: 676, token: OR_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 191)
Conflict at state: 676, token: XOR_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 192)
Conflict at state: 676, token: RSHIFT_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 193)
Conflict at state: 676, token: URSHIFT_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 194)
Conflict at state: 676, token: LSHIFT_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 195)
Conflict at state: 676, token: MOD_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 196)
Conflict at state: 676, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: optionalExpression -> expression
Conflict at state: 676, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 676, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 676, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 676, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 676, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 676, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 676, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 676, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 676, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 676, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 676, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 676, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 676, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 676, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 676, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 676, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 676, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 676, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 676, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 676, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 676, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 676, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 676, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 676, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 676, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 676, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 676, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 676, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 676, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 676, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 676, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 676, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 676, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 676, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 676, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 676, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 688, token: RBRACE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: LBRACE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: SEMI
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: ENUM
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: INTERFACE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: CLASS
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: NATIVE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: PROTECTED
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: PRIVATE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: PUBLIC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: VOLATILE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: TRANSIENT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: STRICTFP
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: ABSTRACT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: FINAL
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: STATIC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: AT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: TEMPLATE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: BANG
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: TILDE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: DEC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: INC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: SUB
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: ADD
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: NEW
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: DOUBLE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: FLOAT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: LONG
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: INT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: SHORT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: BYTE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: CHAR
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: BOOLEAN
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: VOID
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: NullLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: BooleanLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: StringLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: CharacterLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: FloatingPointLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: IntegerLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: SUPER
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: THIS
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: LPAREN
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: Identifier
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: CONTINUE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: BREAK
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: THROW
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: RETURN
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: SYNCHRONIZED
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: SWITCH
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: TRY
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: DO
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: WHILE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: FOR
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: IF
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: ASSERT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: ELSE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: DEFAULT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 688, token: CASE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 719, token: ELSE
  reduce by rule: optionalElseStatement -> 
  shift token (then go to state 744)
Conflict at state: 726, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 751)
Conflict at state: 726, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 726, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 726, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 726, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 726, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 726, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 726, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 726, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 726, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 726, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 726, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 726, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 726, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 726, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 726, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 726, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 726, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 726, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 726, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 726, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 726, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 726, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 726, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 726, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 726, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 726, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 726, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 726, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 726, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 726, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 726, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 726, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 726, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 726, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 726, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 726, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 735, token: CASE
  reduce by rule: switchBlockStatementGroups -> 
  shift token (then go to state 762)
Conflict at state: 735, token: DEFAULT
  reduce by rule: switchBlockStatementGroups -> 
  shift token (then go to state 763)
Conflict at state: 750, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: enhancedForControl -> type variableDeclaratorId COLON expression
Conflict at state: 750, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 750, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 750, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 750, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 750, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 750, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 750, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 750, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 750, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 750, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 750, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 750, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 750, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 750, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 750, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 750, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 750, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 750, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 750, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 750, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 750, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 750, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 750, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 750, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 750, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 750, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 750, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 750, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 750, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 750, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 750, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 750, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 750, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 750, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 750, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 750, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 756, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: resource -> classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 756, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: resource -> classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 756, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 756, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 756, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 756, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 756, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 756, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 756, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 756, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 756, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 756, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 756, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 756, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 756, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 756, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 756, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 756, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 756, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 756, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 756, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 756, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 756, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 756, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 756, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 756, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 756, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 756, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 756, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 756, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 756, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 756, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 756, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 756, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 756, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 756, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 756, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 756, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 758, token: CASE
  reduce by rule: switchBlockStatementGroups -> switchBlockStatementGroupL
  shift token (then go to state 762)
Conflict at state: 758, token: DEFAULT
  reduce by rule: switchBlockStatementGroups -> switchBlockStatementGroupL
  shift token (then go to state 763)
Conflict at state: 760, token: CASE
  reduce by rule: switchBlockStatementGroup -> switchLabelL
  shift token (then go to state 762)
Conflict at state: 760, token: DEFAULT
  reduce by rule: switchBlockStatementGroup -> switchLabelL
  shift token (then go to state 763)
Conflict at state: 766, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: enhancedForControl -> modifierL type variableDeclaratorId COLON expression
Conflict at state: 766, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 766, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 766, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 766, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 766, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 766, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 766, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 766, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 766, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 766, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 766, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 766, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 766, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 766, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 766, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 766, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 766, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 766, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 766, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 766, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 766, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 766, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 766, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 766, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 766, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 766, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 766, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 766, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 766, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 766, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 766, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 766, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 766, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 766, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 766, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 766, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 771, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 771, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 771, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 771, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 771, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 771, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 771, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 771, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 771, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 771, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 771, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 771, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 771, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 771, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 771, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 771, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 771, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 771, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 771, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 771, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 771, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 771, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 771, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 771, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 771, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 771, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 771, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 771, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 771, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 771, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 771, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 771, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 771, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 771, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 771, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 771, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 771, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 771, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)
Conflict at state: 777, token: COLON
  reduce by rule: expression -> expression
  shift token (then go to state 782)
Conflict at state: 777, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 777, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 155)
Conflict at state: 777, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 157)
Conflict at state: 777, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 777, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 777, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 777, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 777, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 777, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 777, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 777, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 777, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 162)
Conflict at state: 777, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 777, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 777, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 777, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 777, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 777, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 777, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 777, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 777, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 777, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 169)
Conflict at state: 777, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 777, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 777, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 777, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 777, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 777, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 777, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 777, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 777, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 777, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 777, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 777, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 194)
Conflict at state: 777, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 195)
Conflict at state: 777, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 196)

4326 Conflict(s) found in grammar.
Done.
